## 1. 准备

### 1.1. 了解情况

介绍一下近两年工作使用的语言、框架、使用的存储组件？

- Golang
- client-go：k8s中controller组件开发的核心框架；
- operator：operator 是描述、部署和管理 kubernetes 应用的一套机制。从实现上讲，operator = CRD + webhook + controller。
- etcd：一个分布式、一致性的键值存储系统。

Golang 用了多少年？2年

找工作的原因和背景？

- 公司云业务发展缓慢，个人成长受限，成就感不足。
- 感觉自身还比较年轻，想出来看下有没有好的机会。

### 1.2. 浏览器输入https://www.futu.com发生的事情？

```
a. 解析URL，获取协议（http/https）、域名、资源路径；然后封装HTTP请求消息；
b. 发送DNS请求将域名解析为IP地址，DNS服务器根据域名，一层一层的查找（./.com/futu.com）;如果DNS还做了负载均衡，返回多个IP中的其中一个IP；
c. 通过socket进协议栈，封装TCP包头。这里关注sport（随机生成）和dport（80/443）。
d. 封装IP包头。这里关注srcip和dstip（DNS解析后已经拿到）。假设客户端有多张网卡，srcip需要查询路由表来确定。
e. 封装MAC头。src mac直接读取网卡的mac获取；dst mac则需要先查arp缓存，没有就发送arp广播获取。
f. 网卡发包，经过交换机、路由器最终到达服务器。
g. 先建立TCP连接，然后建立SSL连接，最后发送HTTP消息。
```

HTTP状态码：

- 500：Internal Server Error
- 501：Not Implemented
- 502：Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。

502可能的原因：

- 上游服务器宕机或进程挂掉；
- 代理服务器配置错误；
- 负载均衡器故障；

### 1.3. 如何用技术解决论坛中“大批量发广告贴”问题？

- 增加验证码机制；
- 增加发帖频率限制；
- 增加人工审核机制；
- 增加举报机制；

### 1.4. Golang基础

1.4.1. 切片和数组有什么区别？

- 长度：array长度固定；slice可以自动扩容；
- 内存分配：array是在栈上分配；slice是在堆上分配；
- 传参：array进行值拷贝；slice传递引用，**多个切片可以共享同一个底层数组**；

1.4.2. 切片底层数据结构、扩容时机和策略？

- 底层数据结构：一个指向数组的指针、切片的长度、切片的容量；
- 扩容时机和策略：当切片的长度超过容量就进行扩容；旧容量<256时，按2x比例增长，否则按1.25x比例增长；

1.4.3. defer方法执行的顺序

设置返回值 -> 执行defer -> 执行ret指令。

1.4.4. 什么是哈希函数？哈希函数有什么特性？

（将任意长度的输入（也称为“消息”）映射到固定长度输出的函数）

- 一致性：固定输入，会有固定输出；
- 唯一性：不同输入，会有不同输出；
- 不可逆：根据输出无法获取输入；
- 雪崩效应：微小变化的输入，会导致输出巨大变化；

1.4.5. map和sync.Map

map并发会panic：检测方法，写的时候设置了hashWriting的标志位，读/写的时候会检查该标志位。

map底层数据结构：

- hmap
- hmap维护buckets
- 一个bmap对应一个bucket，最多存储8个键值对。当发生hash冲突时，会溢出到下一个bmap。（通过overflow指针形成链表）
- bmap中存储keys和values，keys和values存储按照K/K/K/K/V/V/V/V的形式，方便字节对齐，节省内存。

扩容rehash：（在向 map 插入/删除 key 的时候，会进行条件检测）

- 当前没有在进行扩容；
- 装载因子超过阈值，源码里定义的阈值是 6.5；
- overflow 的 bucket 数量过多；

Rehash 具体会影响什么？

- 时间：需要遍历所有元素；
- 内存：创建新的哈希桶，占用额外内存空间；
- 哈希结果：重新计算哈希值，改变哈希表中的位置；

Rehash 数据迁移：

- 先创建新的桶数组；
- 遍历旧桶中的每个元素，计算其在新桶中的索引位置， 然后插入；
- 限制每次迁移的元素数量，如果超过了一定的阈值，则会暂停迁移，等待下一次迁移；

解决并发问题：

- sync.Mutex （锁的竞争十分激烈）
- sync.Map

sync.map方案：

- 通过读写分离，冗余数据结构，空间换时间的思想，来减少耗时。
- read优先：操作read比较快，（原子操作）。
- 双检查机制：read不符合要求时，操作dirty前需要上锁，期间可能发生了变化，read突然又符合要求了。
- 延迟删除：delete时，优先操作read，只是把value赋值为nil。后面提升dirty为read时，才会统一删除。

### 1.5. 网络

1.5.1. TIME_WAIT

TIME_WAIT 状态出现 TCP 的哪个阶段（或者场景）？（主动发起关闭连接的一方，在收到对方的FIN报文后，进入TIME_WAIT状态）

查看 TCP 连接状态需要用什么命令？（netstat、ss）

发现存在大量 TIME_WAIT 状态会存在什么问题？（占用文件描述符，占用端口，占用内存等）

出现大量 TIME_WAIT 的话应用层有什么优化方案？（tcp_tw_reuse、tcp_max_tw_buckets）

1.5.2. 连接池的中心思想是什么？主要解决的是什么问题？（避免频繁地建立和关闭连接，从而提高应用程序的性能和可伸缩性。）

1.5.3. 了解 TCP 中的粘包现象吗？

- TCP是面向字节流的协议，当两个消息的某个部分被分到同一个TCP报文时，就是说的TCP粘包问题；
- 解决：特殊字符作为边界（\r\n）；自定义包头和数据体；

1.5.4. 如果有一个请求需要发送数据，但是我想把包拆分开（不等待），在应用层应该怎么做？（丢到消息队列，多个消费者同时处理）

### 1.6. etcd

etcd包含四个部分：

- HTTP Server：用于处理用户发送的API请求、etcd节点的同步与心跳请求；
- Store：事务处理；
- Raft：强一致性算法；
- WAL：Write Ahead Log（预写式日志），是etcd的数据存储方式；

https://draveness.me/etcd-introduction/

http://www.xuyasong.com/?p=1706

### 1.7. 存储

1.7.1. 如果一个表中有主键和普通索引，查询命中主键和普通索引有什么区别？

当使用主键索引时，MySQL会直接定位到数据行；而使用普通索引时，MySQL会先定位到索引行，然后再根据索引行中的指针找到数据行。因此，在查询命中主键时，查询速度更快。

1.7.2 InnoDB 存储引擎支持四种隔离级别，分别是：未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（serializable）。

- 未提交读：一个事务可以读取另一个事务未提交的数据，可能会出现脏读、不可重复读和幻读问题。
- 提交读：一个事务只能读取另一个事务已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。
- 可重复读：一个事务在执行期间看到的数据是一致的，即使其他事务对该数据进行了修改，也只能看到该事务开始时的值。可以避免脏读和不可重复读问题，但是可能会出现幻读问题。
- 串行化：最高的隔离级别，所有事务串行执行，可以避免脏读、不可重复读和幻读问题，但是会影响并发性能。

- 不可重复读是指在同一个事务中，多次读取同一条记录，但是由于其他事务的修改，每次读取的结果都不同。
- 幻读是指在同一个事务中，多次执行同一个查询，但是由于其他事务的插入或删除，每次查询的结果都不同。

### 1.8. 场景

1.8.1 如果做一个翻译服务，翻译能力来自于供应商，如何从技术上对几家（A、B、C）供应商作出评估？

- 翻译质量（人工评估、机器评估(准确性，流畅性，TER编辑距离)）
- 翻译速度
- 语种
- 技术支持
- 数据安全

如果几家都要接入，且各家之间的翻译能力都各有优劣，那应该如何去搭建这个服务的框架？

- 调度器
- 数据采集 / 反馈机制，帮助调度器更好地工作
- 可扩展性，固化供应商的接入标准，方便未来扩展更多供应商选择

除了回答的这些方面，一个服务的设计还需要注意什么？

- 正常服务应该提供的网关，包括鉴权、限流、多租户
- 提供给外部的服务需要注意 SLA，SLA 则围绕日志、监控、Tracing 做文章
