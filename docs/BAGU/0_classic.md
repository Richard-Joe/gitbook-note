# 老一套

## 1. 编译篇

### 1.1. 编译阶段做什么？链接阶段做什么？

编译过程：将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

汇编过程：将汇编代码转变成机器可以执行的指令。

经过 `预处理`、`编译`、`汇编`三个过程（一起叫做**编译阶段**），C源代码文件才生了**目标文件**。

**链接阶段**：把各个模块之间的相互引用的部分都处理好，使得各个模块之间能够正确地衔接起来形成可执行文件。这个过程主要包括：**地址和空间分配、符号决议、重定位**。

### 1.2. 动态链接和静态链接的区别

静态链接：**生成可执行文件之前就完成了所有链接；可执行文件大；空间浪费（存在多个副本）；更新困难；**

动态链接：**程序执行才进行链接；可执行文件小；节约内存（共享一个副本）；牺牲少部分性能；只需更新库即可；**

动态链接出现的原因就是为了解决静态链接的两个问题：空间浪费、更新困难。

### 1.3. 目标文件中有什么？

可执行文件、目标文件、链接库，他们使用对应的格式存储：

- Windows下 PE（Portable Executable）
- Linux下 ELF（Executable Linkable Format）

以ELF格式为例，目标文件里面内容：

- ELF Header
- 代码段（.text）
- 数据段（.data）：存放**已经初始化**的全局变量和局部静态变量。
- 只读数据段（.rodata）：比如常量。
- bss段（.bss）：存放**未初始化**的全局变量和局部静态变量。
- 其他段：.init、.debug、.comment、.symtab等
- 段表（Section Header Table）：描述所有段的信息：段名、段长度、偏移、读写权限、其他属性。

## 2. 操作系统篇

### 2.1. malloc原理

### 2.2. fork和vfork原理

### 2.3. epoll原理

### 2.4. 死锁定义和避免

### 2.5. 进程和线程的区别

## 3. 网络篇

## 4. 内核篇

### 2.1. linux启动做了哪些事情

### 2.2. 内核分配内存函数和区别

### 2.3. 内核同步机制

### 2.4. 抢占、中断、锁

**持有锁的任务不能被抢占。**

### 2.5. 发生异常时，CPU会做什么？

## 参考

https://os.phil-opp.com/zh-CN/cpu-exceptions/
