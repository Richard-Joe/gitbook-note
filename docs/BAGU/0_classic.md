# 老一套

## 1. 编译篇

### 1.1. 编译阶段做什么？链接阶段做什么？

编译过程：将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

汇编过程：将汇编代码转变成机器可以执行的指令。

经过 `预处理`、`编译`、`汇编`三个过程（一起叫做**编译阶段**），C源代码文件才生了**目标文件**。

**链接阶段**：把各个模块之间的相互引用的部分都处理好，使得各个模块之间能够正确地衔接起来形成可执行文件。这个过程主要包括：**地址和空间分配、符号决议、重定位**。

### 1.2. 动态链接和静态链接的区别

静态链接：**生成可执行文件之前就完成了所有链接；可执行文件大；空间浪费（存在多个副本）；更新困难；**

动态链接：**程序执行才进行链接；可执行文件小；节约内存（共享一个副本）；牺牲少部分性能；只需更新库即可；**

动态链接出现的原因就是为了解决静态链接的两个问题：空间浪费、更新困难。

### 1.3. 目标文件中有什么？

可执行文件、目标文件、链接库，他们使用对应的格式存储：

- Windows下 PE（Portable Executable）
- Linux下 ELF（Executable Linkable Format）

以ELF格式为例，目标文件里面内容：

- ELF Header
- 代码段（.text）
- 数据段（.data）：存放**已经初始化**的全局变量和局部静态变量。
- 只读数据段（.rodata）：比如常量。
- bss段（.bss）：存放**未初始化**的全局变量和局部静态变量。
- 其他段：.init、.debug、.comment、.symtab等
- 段表（Section Header Table）：描述所有段的信息：段名、段长度、偏移、读写权限、其他属性。

## 2. 操作系统篇

### 2.1. malloc原理

### 2.2. fork和vfork原理

### 2.3. epoll原理

### 2.4. 死锁定义和避免

### 2.5. 进程和线程的区别

## 3. 网络篇

## 4. 内核篇

### 2.1. linux启动做了哪些事情

### 2.2. 内核分配内存函数和区别

【页为单位】

如果想要 **以页为单位的连续物理页**，使用 **`alloc_pages()`**。

【对象为单位】

slub分配器：**`kmem_cache_alloc()`**

【字节为单位】
通常**以字节为单位**的分配：

- **`kmalloc()`** 确保页在**物理地址上是连续的**（虚拟地址自然也是连续的）。用于申请较小的，连续的物理内存。
	- CONFIG_SLUB情况下：kmalloc在启动的时候会预先创建一些不同大小的slab，会寻找大小刚好合适的slab来分配内存。如果过大，也会使用alloc_pages()来分配内存。
- **`vmalloc()`** 分配的内存虚拟地址是连续的，而**物理地址则无须连续**。用于申请较大的内存，虚拟内存是连续的。分配的内存在VMALLOC_START~VMALLOC_END之间。
	- 从VMALLOC_START~VMALLOC_END，查找空闲的虚拟地址空间，根据size，调用alloc_page()依次分配单个页面，然后映射到找到的连续虚拟地址空间。

### 2.3. 内核同步机制

- **原子操作**：atomic_set、atomic64_set、set_bit（原子位）
- **自旋锁**：持有自旋锁不允许睡眠。
	- spin_lock：获取自旋锁；
	- spin_lock_irq：禁止本地中断，并获取锁；
	- spin_lock_irqsave：保存本地中断状态，禁止本地中断，并获取锁；
	- spin_lock_bh：禁止下半部执行（软中断），并获取锁；
- **读写锁**：读锁被持有时，读者可以继续占用锁，写者要等待所有读者释放锁才能占用。
- **信号量**：一种**睡眠锁**。如果信号量不可用，它将把调用进程置成TASK_INTERRUPTIBLE状态，进入睡眠。
	- 又分：计数信号量、互斥信号量、读写信号量；
- **完成变量**：代替信号量的一种简单方法。
	- wait_for_completion：等待指定的完成变量接收信号；
	- complete：发信号唤醒任何等待的任务；
	- 使用案例：子进程执行或退出时，vfork()系统调用使用完成变量唤醒父进程。
- **~~BKL大内核锁~~**：被移除了。
- **顺序锁**：seq锁，写优先于读，使用案例：**jiffies**。
- **内存屏障**：memory barrier。解决处理器和编译器重排序问题。
	- rmb()、wmb()、barrier()
- **RCU锁**：Read-Copy-Update

优先级：**`中断 > 软中断 > 进程上下文`**；

所以：中断可以抢占软中断，软中断可以抢占进程上下文。

### 2.4. 抢占、中断、锁

调度分两种：抢占式调度、非抢占式调度。**Linux使用的是抢占式调度**。

【**抢占**】分两种：

- **用户抢占**：指内核返回用户空间而做出的抢占。比如：从系统调用返回；从中断返回。
- **内核抢占**：指在内核代码的执行过程中发生的抢占。下面可能发生内核抢占：
	- 中断处理结束并返回内核空间之前；
	- preempt_count从非零变成零；
	- 内核代码显示调用schedule()；
	- 任务在内核中阻塞，触发schedule()；

【**中断**】

内核需要管理硬件，但处理器速度比硬件快很多个级别，不能让处理器等待硬件响应，所以需要一种方式使得**硬件能够通知内核**，让内核响应硬件的请求。

两种方式：

- 轮询：定期检查硬件，开销太大。
- **中断**：<u>让硬件有需要时，给内核发送信号。</u>

【**锁**】

内核抢占发生的条件：**任务不能持有锁**。

通过控制preempt_count，为 0 表示允许抢占，不为 0 表示禁止抢占。

```c
// 关闭抢占
#define preempt_disable() \
do { \
	preempt_count_inc(); \
	barrier(); \
} while (0)
```

### 2.5. 进程上下文和中断上下文

**进程上下文**是一种内核所处的操作模式，此时内核代表进程执行。（例如：执行系统调用或运行内核线程）。进程可以睡眠，也可以调用程序。

一般程序在用户空间执行。当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称**内核“代表进程执行”并处于进程上下文**。

**中断上下文**没有后备进程，不可以睡眠（否则又怎能再对它重新调用呢？）。且具有较严格的时间限制。

### 2.6. 中断栈

中断处理程序（上半部，top half）拥有了自己的栈，每个处理器一个，大小为一页。这个栈就称为**中断栈**。

### 2.7. 为什么需要下半部（bottom half）？

简单说：又想中断处理程序运行的快，又想中断处理程序完成的工作量多。只能把一些工作放到以后去做。

**上半部分简单快速，执行的时候禁止一些或全部中断。下半部分稍后执行，而且执行期间可以响应所有的中断。**

下半部有哪些实现：

- **软中断**
- **tasklet**：基于软中断实现；
- **工作队列**：基于内核线程实现；

### 2.8. 系统调用

用户空间程序无法直接执行内核代码。以**某种方式通知**（这种方式是**软中断**）内核，需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。

**陷入内核时，把参数从用户空间传给内核，参数放在寄存器里。返回值也通过寄存器传递。**

**内核在执行系统调用时，处于进程上下文。**

**在进程上下文中，内核可以休眠，可以被抢占。**

### 2.9. 发生异常时，CPU会做什么？

发生异常时，CPU需要先记录当前程序的上下文，然后再去处理异常，异常处理完成后返回到原先的程序当中。

#### 2.9.1. 异常

【异常定义】：

- **异常**：由于 内部或者外部的一些事件 , 导致 处理器停下正在处理的工作, 转而去处理这些发生的事；
- **处理器状态**：当遇到异常的时候，**先将处理器状态保存起来**, 以便执行完异常处理程序后, 可以恢复处理器状态, 继续执行异常出现点下面的代码；
- **异常出现**：在**一个时间点 可以出现 多个异常**；
- **异常向量**：当异常发生的时候, 程序被强行**从一个固定的内存地址执行, 每个种类的异常都有对应的一固定内存地址**, 这个内存地址就是异常向量 ；

【异常类型】：

ARM架构下支持 7 种异常：

- **Reset**：处理器在工作时, 突然 **按下重启键, 就会触发该异常**;
- **Undefined instructions**：处理器**无法识别指令**的异常；
- **Software interrupt (SWI)**：**软中断**, 软件中需要去打断处理器工作, 可以使用软中断来执行；
- **Prefetch Abort (instruction fetch memory abort)**：**预取指令失败**, ARM 在执行指令的过程中, 要先去预取指令准备执行, 如果预取指令失败, 就会产生该异常；
- **Data Abort (data access memory abort)**：读取数据失败；
- **IRQ (interrupt)**：**普通中断**；
- **FIQ (fast interrupt)**：**快速中断**，比IRQ响应快；

【异常处理】：

异常发生时, ARM 处理器会跳转到对应该异常的 **固定地址** 去执行异常处理程序。这个 固定的地址 就是**异常向量**。

**每个异常类型对应两个异常向量**, 默认是 Normal address。

![exception](images/0/exception.png)

## 参考

https://blog.csdn.net/shulianghan/article/details/80163777
