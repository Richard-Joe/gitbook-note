# è¯­è¨€åŸºç¡€

## 1. å˜é‡ã€å¸¸é‡ã€éšè—

- **`let`** å…³é”®å­—ï¼šå£°æ˜å˜é‡ã€‚
	1. å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ `Immutable`
	2. åŠ ä¸Š**`mut`**ï¼Œä½¿å˜é‡å¯å˜

- **`const`** å…³é”®å­—ï¼šå£°æ˜å¸¸é‡ã€‚
	1. ä¸å¯ä»¥ç”¨ `mut`
	2. å¿…é¡»æ ‡æ³¨ç±»å‹
	3. å¯ä»¥å£°æ˜åœ¨ä»»ä½•ä½œç”¨åŸŸ
	4. åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼

- **`Shadowing`** ï¼šéšè—ã€‚
	1. å¯ä»¥ä½¿ç”¨ `let` å£°æ˜ åŒåæ–°å˜é‡ï¼Œæ–°çš„å˜é‡å°±ä¼š `shadow` ä¹‹å‰å£°æ˜çš„å˜é‡
	2. æ–°çš„å˜é‡ï¼Œç±»å‹å¯ä»¥ä¸ä¹‹å‰ä¸åŒ

## 2. æ•°æ®ç±»å‹ï¼šæ ‡é‡ç±»å‹ã€å¤åˆç±»å‹

- æ ‡é‡ç±»å‹ï¼š
	1. æ•´æ•°ï¼š`i8ã€u8ã€i16ã€u16ã€i32ã€u32ã€i64ã€u64ã€i128ã€u128ã€isizeã€usize`ã€‚é»˜è®¤ç±»å‹æ˜¯ `i32`
	> æ•´æ•°æº¢å‡ºï¼š
	> 	- debugç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼š panicï¼›
	> 	- releaseç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼šæ‰§è¡Œ â€œç¯ç»•â€ æ“ä½œï¼Œä¸ä¼španicï¼›
	3. æµ®ç‚¹ï¼š`f32ã€f64`ã€‚é»˜è®¤ç±»å‹æ˜¯ `f64`
	4. å¸ƒå°”ï¼š`bool`ï¼›å€¼ä¸º`trueã€false`ï¼›å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
	5. å­—ç¬¦ï¼š`char`ï¼›ä½¿ç”¨å•å¼•å·ï¼›å ç”¨**4ä¸ªå­—èŠ‚**å¤§å°ï¼›æ˜¯**Unicodeæ ‡é‡å€¼**

- å¤åˆç±»å‹ï¼š
	1. å…ƒç»„ï¼šæ”¯æŒå¤šä¸ªç±»å‹çš„å€¼æ”¾ä¸€èµ·ï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›`let tup: (i32, f64, char) = (1, 2.0, 'a');`
	2. æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›å­˜æ”¾åœ¨ **`stack`** ä¸Šï¼›`let arr: [i32; 3] = [1,2,3];`ï¼Œä½¿ç”¨å›ºå®šå€¼åˆå§‹åŒ–æ•°ç»„æ—¶ `let arr = [3; 5];`

## 3. å‡½æ•°

- è¯­å¥ï¼ˆstatementï¼‰ï¼šæ‰§è¡Œä¸€äº›åŠ¨ä½œçš„æŒ‡ä»¤
- è¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°ä½“ï¼šç”±ä¸€ç³»åˆ— `statement` ç»„æˆï¼Œå¯é€‰çš„ç”±ä¸€ä¸ª `expression` ç»“æŸï¼›
- è¿”å›å€¼ï¼š`->` ç¬¦å·åå£°æ˜å‡½æ•°è¿”å›å€¼ç±»å‹ï¼›é€šå¸¸æ˜¯å‡½æ•°ä½“ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼›æå‰è¿”å›éœ€ä½¿ç”¨ `return` å…³é”®å­—

## 4. æ§åˆ¶æµ

- `if else`ï¼šæ¡ä»¶å¿…é¡»æ˜¯ `bool` ç±»å‹
- `loop`
- `while`
- `for`ï¼šå®‰å…¨ã€ç®€æ´
- `Range`ï¼š`rev` å¯ä»¥åè½¬ `Range`ï¼Œ`for num in (1..4).rev()`
- `match`

## 5. æ‰€æœ‰æƒ

æ‰€æœ‰æƒæ˜¯ `Rust æœ€æ ¸å¿ƒ`çš„ç‰¹æ€§ï¼Œå®ƒä½¿å¾— `Rust` æ— éœ€ `GC` å°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ã€‚

æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› ï¼Œå°±æ˜¯ç®¡ç† `heap` æ•°æ®ï¼š

- è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `heap` çš„å“ªäº›æ•°æ®ï¼›
- æœ€å°åŒ– `heap` ä¸Šçš„é‡å¤æ•°æ®é‡ï¼›
- æ¸…ç† `heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³ï¼›

### 5.1. æ‰€æœ‰æƒè§„åˆ™

- æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…ï¼›
- æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼›
- å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤ï¼›

### 5.2. å†…å­˜å’Œåˆ†é…

- **å½“å˜é‡èµ°å‡ºä½œç”¨åŸŸæ—¶ï¼ŒRust ä¼šè‡ªåŠ¨è°ƒç”¨`drop`å‡½æ•°ï¼Œå°†å†…å­˜è¿˜ç»™æ“ä½œç³»ç»Ÿ**ï¼›

- **ç§»åŠ¨ï¼ˆMoveï¼‰**ï¼š
![move](images/move.png)

æŠŠ s1 èµ‹å€¼ç»™ s2 , ä¸ºäº†ä¿è¯å†…å­˜å®‰å…¨ï¼š

	Ruståªåœ¨ `stack` ä¸Šå¤åˆ¶ï¼Œæ²¡æœ‰åœ¨ `heap` ä¸Šå¤åˆ¶ï¼›
	Rustè®© s1 å¤±æ•ˆï¼›

å¦‚æœçœŸçš„æƒ³å¯¹ `heap` ä¸Šçš„æ•°æ®åš `æ·±åº¦æ‹·è´`ï¼Œå¯ä»¥ä½¿ç”¨ `clone` æ–¹æ³•ã€‚

- **å¤åˆ¶**ï¼š
	- å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy trait`ï¼Œé‚£ä¹ˆæ—§çš„å˜é‡åœ¨èµ‹å€¼åä»ç„¶å¯ç”¨ï¼›
	- å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`ï¼Œé‚£ä¹ˆ Rust ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`ï¼›

**ç®€å•è¯´ï¼Œstackä¸Šçš„èµ„æºæœ‰copy traitï¼Œheapä¸Šçš„èµ„æºæ²¡æœ‰copy traitã€‚**

ä¸€äº›æ‹¥æœ‰ Copy trait çš„ç±»å‹ï¼š

- æ ‡é‡ç±»å‹
- å…ƒç»„ï¼Œå‰ææ˜¯æ‰€æœ‰å­—æ®µéƒ½æ˜¯copyçš„

### 5.3. å‡½æ•°

- å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå°†å‘ç”Ÿ **ç§»åŠ¨** æˆ– **å¤åˆ¶**ï¼›
- å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­ï¼ŒåŒæ ·ä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»ï¼›

ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒï¼Œæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼ï¼š

- æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶ä»–å˜é‡æ—¶ï¼Œå°±ä¼šå‘ç”Ÿç§»åŠ¨ï¼›
- å½“ä¸€ä¸ªåŒ…å« `heap` æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†ï¼›

## 6. å¼•ç”¨å’Œå€Ÿç”¨

- å¼•ç”¨ï¼š`&`ç¬¦å·ï¼Œå…è®¸å¼•ç”¨æŸäº›å€¼è€Œ**ä¸å–å¾—å…¶æ‰€æœ‰æƒ**ï¼›é»˜è®¤ä¸å¯å˜çš„ï¼›
- å€Ÿç”¨ï¼šæŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°è¿™ä¸ªè¡Œä¸ºå«åšå€Ÿç”¨ï¼›`fn calc_len(s: & String) -> usize`
- å¯å˜å¼•ç”¨ï¼šæ¯”å¦‚`mut & String`ï¼›**åœ¨ç‰¹å®šä½œç”¨åŸŸå†…ï¼ŒæŸå—æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚ï¼ˆé¿å…ç«äº‰ï¼‰**ï¼›
- **å€Ÿç”¨è§„åˆ™**ï¼š
	- ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å¯å˜å¼•ç”¨
	- å¯ä»¥åŒæ—¶æ‹¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨

## 7. åˆ‡ç‰‡ï¼ˆsliceï¼‰

åˆ‡ç‰‡ï¼ˆsliceï¼‰ï¼š`&str`ï¼Œä¹Ÿæ˜¯ä¸€ç§**ä¸æŒæœ‰æ‰€æœ‰æƒ**çš„æ•°æ®ç±»å‹ï¼›

- å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…ï¼›
- å¦‚æœå¯¹ä¸€ä¸ª**å¤šå­—èŠ‚çš„å­—ç¬¦**ä¸­åˆ›å»ºå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç¨‹åºæŠ¥é”™å¹¶é€€å‡ºï¼›

## 8. ç»“æ„ä½“ï¼ˆstructï¼‰

- ä¸€æ—¦ struct çš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„ï¼›

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User { // ä½œä¸ºå‡½æ•°è¿”å›å€¼
        active: true,
        username, // ç®€å†™
        email,    // ç®€å†™
        sign_in_count: 1,
    }
}

let u1 = build_user(String::from("joe@163.com"), String::from("joe"));

let u2 = User {
    email: String::from("tom@163.com"),
    username: String::from("tom"),
    ..u1   // struct æ›´æ–°è¯­æ³•
};

// Tuple struct
// structæœ‰åï¼Œä½†é‡Œé¢å…ƒç´ æ²¡å
struct Point(i32, i32, i32);
let origin = Point(4, 5, 6);

// Unit-Like struct
// æ²¡æœ‰ä»»ä½•å­—æ®µï¼Œé€‚ç”¨äºéœ€è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª traitï¼Œä½†é‡Œé¢æœ‰æ²¡æœ‰éœ€è¦å­˜å‚¨çš„æ•°æ®
struct Solution;
```

- **æ–¹æ³•**ï¼šåœ¨ `impl` å—å®šä¹‰æ–¹æ³•ï¼›æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯ `&self`ï¼Œä¹Ÿå¯ä»¥è·å¾—å…¶æ‰€æœ‰æƒ æˆ– å¯å˜å€Ÿç”¨ï¼›
- **å…³è”å‡½æ•°**ï¼šåœ¨ `impl` å—å®šä¹‰ï¼Œä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼›

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // å…³è”å‡½æ•°
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size
        }
    }
}
```

## 9. æšä¸¾ï¼ˆenumï¼‰

- å¯ä»¥å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­
- æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡
- ä½¿ç”¨`impl`ä¸ºæšä¸¾å®šä¹‰æ–¹æ³•

```rust
#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        println!("{:?}", self);
    }
}
```

Rust æä¾›äº†ç±»ä¼¼ `Null` æ¦‚å¿µçš„æšä¸¾ï¼š`Option<T>`

- `Option<T>` å’Œ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼›
- è‹¥éœ€è¦ä½¿ç”¨`Option<T>`ä¸­çš„`T`ï¼Œéœ€è¦å…ˆè½¬æ¢ï¼›

```rust
enum Option<T> {
    Some(T),
    None,
}
```

## 10. match

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- `æ¨¡å¼`å¯ä»¥æ˜¯å­—é¢å€¼ã€å˜é‡åã€é€šé…ç¬¦...
- æ¨¡å¼å¯ä»¥ç»‘å®šå€¼ï¼Œæ¯”å¦‚ä» enum å˜ä½“ä¸­æå–å€¼ï¼›
- match åŒ¹é…**å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½**ï¼›å¦‚æœä¸æƒ³å¤„ç†ï¼Œåˆ™ä½¿ç”¨ `_ é€šé…ç¬¦`æ¥æ›¿ä»£å…¶ä½™å€¼ï¼›

```rust
let x = Some(5);
match x {
    None => None,
    Some(i) => Some(i + 1),
}

let v = 0u8;
match v {
    1 => 1,
    3 => 3,
    5 => 5,
    _ => 999,
}
```

## 11. if let

- åª**å…³å¿ƒä¸€ç§åŒ¹é…**è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µï¼›
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½ï¼›

```rust
let x = Some(5);
if let Some(5) = x {
    println!("five")
} else {
	println!("others")
}
```

## 12. Packageã€Crateã€Moduleã€Path

- `Crate`ï¼š
	- ä¸¤ç§ç±»å‹ï¼š`binary`ã€`library`
	- `Crate Root`ï¼šæŒ‡æºä»£ç å…¥å£æ–‡ä»¶
		- `src/main.rs`  ( binary )
		- `src/lib.rs`  ( library )

- `Package`ï¼š
	- `Cargo.toml`ï¼šæè¿°äº†å¦‚æœæ„å»º `Crates`
	- åªèƒ½åŒ…å« `0-1` ä¸ª `library crate`
	- å¯ä»¥åŒ…å« `ä»»æ„æ•°é‡` çš„ `binary crate`
	- ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`

- `Module`ï¼šåœ¨ä¸€ä¸ª `crate` å†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
	- æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§ï¼ˆpublicã€privateï¼‰
	- **`mod`** å…³é”®å­—ï¼Œå¯åµŒå¥—

- `Path`ï¼š
	- ä¸¤ç§å½¢å¼ï¼šç»å¯¹è·¯å¾„ï¼ˆæ¨èï¼‰ã€ç›¸å¯¹è·¯å¾„
	- æ ‡è¯†ç¬¦ `::`
	- **`super`** å…³é”®å­—ï¼Œç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„`..`

- `privacy boundary`ï¼šç§æœ‰è¾¹ç•Œ
	- Rustä¸­æ‰€æœ‰æ¡ç›®ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€structã€enumã€æ¨¡å—ã€å¸¸é‡ï¼‰**é»˜è®¤æ˜¯ç§æœ‰çš„**ã€‚
	- çˆ¶æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—çš„ç§æœ‰æ¡ç›®
	- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
	- **`pub`** å…³é”®å­—æ ‡è®°æ¡ç›®ä¸ºå…¬å…±çš„

- **`pub struct`**ï¼š
	- `struct` æ˜¯å…¬å…±çš„ï¼Œä½†**é‡Œé¢çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„**
	- é‡Œé¢çš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½® `pub` æ¥å˜æˆå…¬æœ‰çš„

- **`pub enum`**ï¼š
	- `enum` æ˜¯å…¬å…±çš„ï¼Œ
	- **`enum` çš„å˜ä½“ä¹Ÿéƒ½æ˜¯å…¬å…±çš„**

- **`use`**ï¼šå°† `path` å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…ï¼Œï¼ˆä½œç”¨åŸŸå†…**ç§æœ‰**ï¼‰
	- å‡½æ•°ï¼šæƒ¯ç”¨åšæ³•æ˜¯å°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šçˆ¶çº§ï¼‰
	- `structã€enum`ï¼šæƒ¯ç”¨åšæ³•æŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šæœ¬çœï¼‰ï¼ˆé™¤éä¸¤ä¸ªæ¨¡å—ä¸­çš„ç»“æ„ä½“åç§°ç›¸åŒï¼‰
	- **`as`** å…³é”®å­—ï¼šå¯ä»¥ç»™å¼•å…¥è·¯å¾„æŒ‡å®šï¼ˆæœ¬åœ°ï¼‰åˆ«å
	- **`pub use`**ï¼šé‡æ–°å¯¼å‡ºåç§°
	- å¯ä»¥ä½¿ç”¨ **åµŒå¥—è·¯å¾„** æ¸…ç†å¤§é‡çš„ `use` è¯­å¥
	- æ”¯æŒé€šé…ç¬¦ `*`

```rust
// åµŒå¥—è·¯å¾„
use std::{cmp::Ordering, io}
use std::io::{self, Write}
```

- **å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶ä»–æ–‡ä»¶**
	- æ¨¡å—ååé¢æ˜¯ `;`
	- Rust ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹

## 13. Vectorã€Stringã€HashMap

- Vector

```rust
// Vector
let mut v: Vec<i32> = Vec::new();
let mut v1 = vec![1,2,3];
v.push(99);
v.get(0);
for item in  v {}
for (i, item) in v.iter().enumerate() {}

enum Cell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    Cell::Int(1),
    Cell::Float(2.34),
    Cell::Text(String::from("red")),
]
```

- Stringï¼š**å­—ç¬¦ä¸²åœ¨Rustä¸­ä½¿ç”¨ `UTF-8` ç¼–ç **
	- `String`  æ¥è‡ªæ ‡å‡†åº“
	- `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œæ¥è‡ªRustæ ¸å¿ƒè¯­è¨€
	- å…¶ä»–å­—ç¬¦ä¸²ç±»å‹ï¼š`OsStringã€OsStrã€CStringã€CStr`
	- **Rustä¸­å­—ç¬¦ä¸²ä¸æ”¯æŒç´¢å¼•è¯­æ³•è®¿é—®**ã€‚åŸå› ï¼š
		- 1. ä¸å®‰å…¨ï¼Œè¶Šç•Œé—®é¢˜ï¼›
		- 2. ç´¢å¼•æ“ä½œåº”æ¶ˆè€—O(1)ï¼Œä½†Stringæ— æ³•ä¿è¯è¿™ä¸ªæ—¶é—´ï¼Œå› ä¸ºéœ€è¦éå†æ‰€æœ‰å†…å®¹æ‰èƒ½ç¡®å®šæœ‰å¤šå°‘åˆæ³•å­—ç¬¦ï¼›
	- `String` æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…
	- Rustä¸­çœ‹å¾…å­—ç¬¦ä¸²æœ‰ä¸‰ç§æ–¹å¼ï¼š
		- å­—èŠ‚ï¼ˆBytesï¼‰
		- æ ‡é‡å€¼ï¼ˆScalar Valuesï¼‰
		- å­—å½¢ç°‡ï¼ˆGrapheme Clustersï¼‰
	- Rustä¸­ï¼Œ**å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„**ï¼ˆ**`1-4`ä¸ªå­—èŠ‚**ï¼‰
	- åˆ‡å‰²å­—ç¬¦ä¸²ï¼Œå¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œ**å¦‚æœè·¨è¶Šäº†å­—ç¬¦è¾¹ç•Œï¼Œç¨‹åºå°±ä¼španic**ã€‚

```rust
let blue = "Blue".to_string();
let mut red = String::from("Red");
red.push_str("black");
red.push_str(&blue);  // é™„åŠ å­—ç¬¦ä¸²åˆ‡ç‰‡
red.push('ğŸ˜‚');      // é™„åŠ å•ä¸ªå­—ç¬¦

let color = red + &blue; // fn add(self, s: &str) -> String
// æ³¨æ„ï¼šredå‘ç”Ÿäº†ç§»åŠ¨ï¼Œæ‰€æœ‰æƒè¿›è¡Œäº†è½¬ç§»ï¼Œåç»­æ— æ³•ç»§ç»­ä½¿ç”¨

let s = format!("{}-{}", "foo", "bar");

// å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç 
println!("{}", "a".len());  // æ‰“å° 1
println!("{}", "Ğ´".len());  // æ‰“å° 2
println!("{}", "à¤µ".len());  // æ‰“å° 3
println!("{}", "ğŸ˜‚".len()); // æ‰“å° 4

// éå†
for i in color.chars() {}  // æƒ³å¾—åˆ° æ ‡é‡å€¼
for i in color.bytes() {}  // æƒ³å¾—åˆ° å­—èŠ‚
```

- HashMap
	- åœ¨å…ƒç´ ç±»å‹ä¸º `Tuple`ï¼ˆä¸¤ä¸ªå€¼ï¼‰ çš„ `Vector` ä¸Šä½¿ç”¨ `collect`æ–¹æ³•ï¼Œå¯ä»¥ç»„å»ºä¸€ä¸ª `HashMap` 
	- **æ‰€æœ‰æƒ**ï¼š
		- **å¯¹äºå®ç°äº† `Copy trait` çš„ç±»å‹ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ã€‚**æ¯”å¦‚ `i32` 
		- **å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè½¬ç§»ç»™ `HashMap` ã€‚**æ¯”å¦‚ `String` 
		- å¦‚æœå°†**å€¼çš„å¼•ç”¨**æ’å…¥åˆ° `HashMap` ï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨ï¼›ä½†è¿™æœŸé—´å¿…é¡»ä¿æŒå¼•ç”¨çš„å€¼æœ‰æ•ˆ
	- **Hashå‡½æ•°**ï¼š
		- é»˜è®¤æƒ…å†µä¸‹çš„hashå‡½æ•°ï¼Œå¯ä»¥æŠµæŠ—Dosæ”»å‡»ï¼Œå®‰å…¨æ€§æ›´å¥½ï¼Œä½†ä¸æ˜¯æœ€å¿«çš„ç®—æ³•ï¼›
		- å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` ï¼ˆæŒ‡å®ç°äº† `BuildHasher trait` çš„ç±»å‹ï¼‰æ¥åˆ‡æ¢ï¼›

```rust
let mut map: HashMap<i32, String> = HashMap::new();
map.insert(10, String::from("red"));
let v = map.get(&10);
match v {
    None => println!("not exist"),
    Some(s) => println!("{}", s),
}

let color = vec![String::from("red"), String::from("blue")];
let nums = vec![100, 200];
let mut map: HashMap<_, _> = color.iter().zip(nums.iter()).collect();
for (k,v) in &map {
    println!("{}: {}", k, v)
}
map.entry(&String::from("black")).or_insert(&300); // keyä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥

let text = "hello world wonderful world";
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
println!("{:#?}", map);
// entryæ–¹æ³•ï¼šè¿”å› enum Entryï¼Œä»£è¡¨å€¼æ˜¯å¦å­˜åœ¨
// or_insertæ–¹æ³•ï¼š
//        å¦‚æœ key å­˜åœ¨ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
//        å¦‚æœ key ä¸å­˜åœ¨ï¼Œå°†æ–°é”®å€¼(k,v)æ’è¿›å»ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
```

## 14. é”™è¯¯å¤„ç†

- å¯æ¢å¤ï¼š`Result<T, E>`
- ä¸å¯æ¢å¤ï¼š`panic!` å®

**panicï¼š**

- é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ panic å‘ç”Ÿæ—¶ï¼Œç¨‹åºä¼š **å±•å¼€ï¼ˆunwindï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆRustæ²¿è°ƒç”¨æ ˆå¾€å›èµ°ï¼Œæ¸…ç†æ¯ä¸€ä¸ªé‡åˆ°çš„æ•°æ®ï¼‰
- æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼Œå¯ä»¥æŠŠè¿™ä¸€è¡Œä¸ºæ”¹ä¸º **ç«‹å³ä¸­æ­¢ï¼ˆabortï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆç”±OSè¿›è¡Œæ¸…ç†ï¼‰
	- åœ¨Cargo.tomlä¸­è®¾ç½®ï¼š
```toml
[profile.release]
panic = 'abort'
```
- å›æº¯ä¿¡æ¯ï¼šè®¾ç½®ç¯å¢ƒå˜é‡ `RUST_BACKTRACE`ï¼›debugæ¨¡å¼ï¼›

**Resultæšä¸¾ï¼š**

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**é”™è¯¯å¤„ç†ï¼š**

- **`match`**
- **`unwrap`**ï¼šmatchè¡¨è¾¾å¼çš„ä¸€ä¸ªå¿«æ·æ–¹å¼ï¼›
- **`expect`**ï¼šå¯æŒ‡å®šé”™è¯¯ä¿¡æ¯

```rust
let f = File::open("hello.ext").unwrap();
let f = File::open("hello.ext").expect("cannot open file");
```

**ä¼ æ’­é”™è¯¯ï¼š**

- **`?` è¿ç®—æ³•**ï¼šä¼ æ’­é”™è¯¯çš„å¿«æ·æ–¹å¼
- **`from` å‡½æ•°**ï¼šç”¨äºé”™è¯¯ä¹‹é—´çš„è½¬æ¢ï¼›åœºæ™¯ï¼šé’ˆå¯¹ä¸åŒçš„é”™è¯¯åŸå› ï¼Œè¿”å›åŒä¸€ç§é”™è¯¯ç±»å‹ï¼›
	- è¦æ±‚ï¼šæ¯ä¸ªé”™è¯¯ç±»å‹éƒ½å®ç°äº†è½¬æ¢ä¸ºæ‰€è¿”å›çš„é”™è¯¯ç±»å‹çš„fromå‡½æ•°ï¼›
- **`main` å‡½æ•°**çš„è¿”å›ç±»å‹æ˜¯ `()`ï¼Œ`main` å‡½æ•°çš„è¿”å›ç±»å‹ä¹Ÿå¯ä»¥æ˜¯ `Result<T, E>`
	- main è¿”å›ç±»å‹å†™ï¼š`Result<(), Box<dyn Error>>`
	- `Box<dyn Error>` æ˜¯ trait å¯¹è±¡ï¼Œè¡¨ç¤ºä»»ä½•å¯èƒ½çš„é”™è¯¯ç±»å‹ï¼›

```rust
fn open_file() -> Result<String, io::Error> {
    let f = File::open("hello.ext")?;
    Ok(String::from("ok"))
}

fn read_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.ext")?.read_to_string(&mut s)?;
    Ok(s)
}
```

## 15. æ³›å‹

- ä½¿ç”¨æ³›å‹çš„ä»£ç å’Œä½¿ç”¨å…·ä½“ç±»å‹çš„ä»£ç è¿è¡Œé€Ÿåº¦æ˜¯ä¸€æ ·çš„ã€‚
- å•æ€åŒ–ï¼ˆmonomorphizationï¼‰ï¼šåœ¨ç¼–è¯‘æ—¶å°†æ³›å‹æ›¿æ¢ä¸ºå…·ä½“ç±»å‹

```rust
// å‡½æ•°
fn largest<T>(list: &[T]) -> T {}

// ç»“æ„ä½“
struct Point<T, U> {
    x: T,
    y: U,
}

// æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// æ–¹æ³•
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {}
}
```

## 16. Trait

- ç±»ä¼¼`Interface`ï¼ŒæŠ½è±¡çš„å®šä¹‰å…±äº«è¡Œä¸º
- `Trait bounds`ï¼šæ³›å‹ç±»å‹å‚æ•°æŒ‡å®šä¸ºå®ç°äº†ç‰¹å®šè¡Œä¸ºçš„ç±»å‹
- `trait` å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•ï¼Œæ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œï¼›
- å®ç°è¯¥ `trait` çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°ï¼›
- å®ç° `trait` çš„çº¦æŸï¼š**è¿™ä¸ªç±»å‹ æˆ– è¿™ä¸ª trait æ˜¯åœ¨æœ¬åœ° `crate` é‡Œå®šä¹‰çš„**ï¼Œæ‰€ä»¥**æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹æ¥å®ç°å¤–éƒ¨çš„ trait**ï¼›
- å¯ä»¥åœ¨ `trait` é‡Œé¢å®šä¹‰**é»˜è®¤å®ç°çš„æ–¹æ³•**ï¼›**é»˜è®¤å®ç°çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ trait ä¸­å…¶ä»–çš„æ–¹æ³•ï¼Œå³ä½¿è¿™ä¸ªæ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°**ï¼›
- **æ— æ³•ä»æ–¹æ³•çš„é‡å†™å®ç°é‡Œé¢è°ƒç”¨é»˜è®¤çš„å®ç°**ï¼›
- `trait` å¯ä»¥**ä½œä¸ºå‚æ•°**ï¼Œä¸‰ç§å†™æ³•ï¼š1. implã€2. trait boundã€3. trait bound where
- `trait` å¯ä»¥**ä½œä¸ºè¿”å›ç±»å‹**ï¼›
	- **`impl Trait` åªèƒ½è¿”å›ä¸€ç§ç¡®å®šçš„ç±»å‹**ï¼Œè¿”å›å¯èƒ½ä¸åŒçš„ç±»å‹ä¼šæŠ¥é”™ï¼›
- å¯ä»¥ä½¿ç”¨`Trait bound` **æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•**
- **è¦†ç›–å®ç°ï¼ˆblanket implementationsï¼‰**ï¼šå¯ä»¥ä¸ºæ»¡è¶³`Trait bounds`çš„æ‰€æœ‰ç±»å‹ä¸Šå®ç°`trait`

```rust
// å®šä¹‰ trait
pub trait Summary {
    fn summarize(&self) -> string;

    fn summarize_default(&self) -> string {
        format!("default {}", self.summarize())
    }
}

pub struct NewsArticle {...}

// å®ç° trait
impl Summary for NewsArticle {
    fn summarize(&self) -> string {
        format!("{}", "article")
    }
}

// trait ä½œä¸ºå‚æ•°
pub fn notify(item: impl Summary) {
    println!("news {}", item.summarize())
}
// è¦æ±‚ item å®ç°äº†å¤šä¸ª trait
pub fn notify1(item: impl Summary + Display) {
    println!("news {}", item.summarize())
}

// Trait bound å†™æ³•
pub fn notify<T: Summary + Display>(item1: T, item2: T) {
    println!("news {}", item.summarize())
}

// Trait bound ä½¿ç”¨ where
pub fn notify<T, U>(a: T, b: U) -> string
where
    T: Summary + Display,
    U: Clone + Debug,
{
    println!("news {}", item.summarize())
}

// trait ä½œä¸ºè¿”å›ç±»å‹
pub fn notify(s: &str) -> impl Summary {
    NewsArticle {...}
}

// Trait bound æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•
struct Pair<T> {
    x: T,
    y: T,
}
impl<T> Pair<T> {
    // æ‰€æœ‰çš„Pairç±»å‹ï¼Œéƒ½æœ‰newå‡½æ•°
    fn new(x: T, y: T) -> self{
        Self { x, y }
    }
}
impl<T: Display + PartialOrd> Pair<T> {
    // åªæœ‰å®ç°äº†(Display+PartialOrd)è¿™ä¸¤ä¸ªtraitçš„Pairç±»å‹ï¼Œæ‰æ‹¥æœ‰cmpå‡½æ•°
    fn cmp(&self) {...}
}

// æ ‡å‡†åº“ string.rs ä¸­ï¼Œä½¿ç”¨äº†è¦†ç›–å®ç°
// ä¸ºæ‰€æœ‰å®ç°äº†Displayè¿™ä¸ªtraitçš„ç±»å‹Tï¼Œå®ç°ToStringè¿™ä¸ªtrait
impl<T: Display> ToString for T {
    default fn to_string(&self) -> string {}
}
```

## 17. ç”Ÿå‘½å‘¨æœŸ

- Rust çš„æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
- ç”Ÿå‘½å‘¨æœŸï¼šå¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
- å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯éšå¼çš„ã€å¯è¢«æ¨æ–­çš„ï¼›å½“æ— æ³•è¢«ç¼–è¯‘å™¨æ¨æ–­æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
- ç”Ÿå‘½å‘¨æœŸå­˜åœ¨çš„ä¸»è¦ç›®æ ‡ï¼šé¿å…æ‚¬å‚å¼•ç”¨ï¼ˆdangling referenceï¼‰
- å€Ÿç”¨æ£€æŸ¥å™¨ï¼šæ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦åˆæ³•
- ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ä¸ä¼šæ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
- å½“æŒ‡å®šäº†æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå‡½æ•°å¯ä»¥æ¥æ”¶å¸¦æœ‰ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
- ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ï¼šæè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸçš„å…³ç³»ï¼Œä½†ä¸å½±å“ç”Ÿå‘½å‘¨æœŸ
- é™æ€ç”Ÿå‘½å‘¨æœŸï¼šæ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´ã€‚`let s: &'static str = "hello";`

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	if x > y {
		x
	} else {
		y
	}
}

struct ImportantExcerpt<'a> {
	part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
	fn level(&self) -> i32 {
		3
	}
}

fn longest_with_an_annoucement<'a, T>
    (x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display,
{
	println!("Announcement! {}", ann)
	if x > y {
		x
	} else {
		y
	}
}
```

ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼š

- ç¼–è¯‘å™¨è€ƒè™‘çš„ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œæ— éœ€æ˜¾ç¤ºæ ‡æ³¨
- å¦‚æœç¼–è¯‘å™¨æ— æ³•æ¨æ–­ï¼Œåˆ™ç¼–è¯‘é”™è¯¯
- è¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼šå‡½æ•°/æ–¹æ³•çš„å‚æ•°
- è¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼šå‡½æ•°/æ–¹æ³•çš„è¿”å›å€¼
- è§„åˆ™é€‚ç”¨äº fn å®šä¹‰å’Œ impl å—

ä¸‰ä¸ªçœç•¥è§„åˆ™ï¼š

1. æ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼›
2. å¦‚æœåªæœ‰ 1 ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼›
3. å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ &self æˆ– &mut selfï¼ˆæ–¹æ³•ï¼‰ï¼Œé‚£ä¹ˆ self çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼›


## 18. æµ‹è¯•

- æµ‹è¯•ï¼š`#[cfg(test)]`ã€`#[test]`
- æ–­è¨€ï¼š`assert!`ã€`assert_eq!`ã€`assert_ne!`
- ææ…Œï¼š`#[should_panic]`
- å¯ä½¿ç”¨ `Result<T, E>` ä½œä¸ºè¿”å›ç±»å‹
- é»˜è®¤ `cargo test` å¹¶è¡Œè¿è¡Œæµ‹è¯•ï¼Œæ§åˆ¶çº¿ç¨‹æ•°é‡ `--test-threads`
- æµ‹è¯•é€šè¿‡ï¼Œä¸ä¼šçœ‹åˆ°æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„å†…å®¹ï¼›å¦åˆ™å¯ä»¥çœ‹åˆ°
- æŒ‡å®šæµ‹è¯•åç§°è¿è¡Œæµ‹è¯•ï¼š`cargo test test-name`
- å¿½ç•¥æµ‹è¯•ï¼š`#[ignore]`
- åªè¿è¡Œè¢«å¿½ç•¥çš„æµ‹è¯•ï¼š`cargo test -- --ignored`
- é›†æˆæµ‹è¯•ï¼š`tests`ç›®å½•
- ç¯å¢ƒå˜é‡ï¼š`env::var("xx")`
- æ ‡å‡†è¾“å‡ºï¼š`println!`
- æ ‡å‡†é”™è¯¯ï¼š`eprintln!`

## 19. é—­åŒ…

- åŒ¿åå‡½æ•°ï¼Œå¯ä»¥ä¿å­˜ä¸ºå˜é‡ã€ä½œä¸ºå‚æ•°
- é—­åŒ…ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œç¼–è¯‘å™¨é€šå¸¸èƒ½æ¨æ–­å‡ºç±»å‹ï¼›ä½†ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ·»åŠ ç±»å‹æ ‡æ³¨
- è®°å¿†åŒ–ï¼ˆmemoizationï¼‰ï¼šåˆ›å»ºä¸€ä¸ª structï¼Œ**å®ƒæŒæœ‰é—­åŒ…åŠå…¶è°ƒç”¨ç»“æœ**
	- struct ä¸­éœ€è¦æŒ‡æ˜é—­åŒ…çš„ç±»å‹
	- **æ¯ä¸ªé—­åŒ…å®ä¾‹éƒ½æœ‰è‡ªå·±å”¯ä¸€çš„åŒ¿åç±»å‹**ï¼Œå³ä½¿ä¸¤ä¸ªé—­åŒ…ç­¾åå®Œå…¨ä¸€æ ·
	- éœ€è¦ä½¿ç”¨ï¼š**æ³›å‹å’Œ Trait Bound**
- **æ‰€æœ‰çš„é—­åŒ…éƒ½è‡³å°‘å®ç°äº†ä»¥ä¸‹ trait ä¹‹ä¸€**ï¼š
	- Fn
	- FnMut
	- FnOnce
- **é—­åŒ…å¯ä»¥è®¿é—®å®šä¹‰å®ƒçš„ä½œç”¨åŸŸå†…çš„å˜é‡ï¼Œè€Œæ™®é€šå‡½æ•°åˆ™ä¸èƒ½**
	- ä¼šäº§ç”Ÿå†…å­˜å¼€é”€
	- é—­åŒ…ä»æ‰€åœ¨ç¯å¢ƒä¸­æ•è·å€¼çš„æ–¹å¼ï¼š
		- å–å¾—æ‰€æœ‰æƒï¼šFnOnce
		- å¯å˜å€Ÿç”¨ï¼šFnMut
		- ä¸å¯å˜å€Ÿç”¨ï¼šFn
	- Rustå¦‚ä½•æ¨æ–­å…·ä½“ä½¿ç”¨å“ªä¸ª traitï¼š
		- æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº† FnOnce
		- æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº† FnMut
		- æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº† Fn
- `move` å…³é”®å­—ï¼š**å¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ**
	åœºæ™¯ï¼šå½“å°†é—­åŒ…ä¼ é€’ç»™æ–°çº¿ç¨‹ä»¥ç§»åŠ¨æ•°æ®ä½¿å…¶å½’æ–°çº¿ç¨‹æ‰€æœ‰æ—¶
- æœ€ä½³å®è·µï¼šå½“æŒ‡å®š Fn trait bound ä¹‹ä¸€æ—¶ï¼Œé¦–å…ˆç”¨ Fnï¼ŒåŸºäºé—­åŒ…ä½“é‡Œçš„æƒ…å†µï¼Œç¼–è¯‘å™¨ä¼šå†å‘Šè¯‰ä½ éœ€è¦ä½¿ç”¨ FnOnce æˆ– FnMut

```rust
let c1 = |x: u32| -> u32 { x + 1 };
let c2 = |x| { x + 1 };
let c3 = |x| x + 1;

let x = vec![1,2,3];
let eq_x = move |z| z == x;
// x å·²å‘ç”Ÿç§»åŠ¨ï¼Œè¿™åé¢æ— æ³•å†ä½¿ç”¨x
```

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    map: HashMap<u32, u32>,
}

impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            map: HashMap::new(),
        }
    }

    fn value(&mut self, key: u32) -> u32 {
        let v = self.map.get(&key);
        match v {
            Some(i) => *i,
            None => {
                let calc = (self.calculation)(key);
                self.map.insert(key, calc);
                calc
            }
        }
    }
}

fn main() {
    let mut closure = Cacher::new(|num| {
        println!("calculation slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    println!("one {}", closure.value(99));
    println!("two {}", closure.value(99));
    println!("three {}", closure.value(99));
    println!("one {}", closure.value(100));
    println!("two {}", closure.value(100));
}
```

## 20. è¿­ä»£å™¨

- æ‰€æœ‰çš„è¿­ä»£å™¨éƒ½å®ç°äº† `Iterator trait`
	- å®ç° `Iterator trait` éœ€è¦å®šä¹‰ä¸ª Item ç±»å‹ï¼Œå®ƒç”¨äº next æ–¹æ³•çš„è¿”å›ç±»å‹
	- next æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€é¡¹ï¼Œè¿”å›ç»“æœåŒ…è£¹åœ¨ Some é‡Œï¼Œè¿­ä»£ç»“æŸåˆ™è¿”å› None
- `iter` æ–¹æ³•ï¼šåœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
- `into_iter` æ–¹æ³•ï¼šåˆ›å»ºçš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒ
- `iter_mut` æ–¹æ³•ï¼šè¿­ä»£å¯å˜çš„å¼•ç”¨
- æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³•ï¼šnextã€sumç­‰
- è¿­ä»£å™¨é€‚é…å™¨ï¼šæŠŠè¿­ä»£å™¨è½¬æ¢ä¸ºä¸åŒç§ç±»çš„è¿­ä»£å™¨ï¼›æ¯”å¦‚ mapã€filter

```rust
pub trait Iterator {
	type Item;
	fn next(&mut self) -> Option<Self::Item>;
}

let v1 = vec![1, 3, 4, 6, 7, 9, 10];
let it = v1.iter().filter(|x| *x % 2 == 0);
```

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let s: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();

    println!("{}", s);
}
```

## 21. å‘å¸ƒ

Cargo ä¸»è¦æœ‰ä¸¤ä¸ª profileï¼š

- dev profileï¼šé€‚ç”¨äºå¼€å‘ï¼Œcargo build
- release profileï¼šé€‚ç”¨äºå‘å¸ƒï¼Œcargo build --release

è‡ªå®šä¹‰ profileæ—¶ï¼Œåœ¨ `Cargo.toml` é‡Œæ·»åŠ  `[profile.xxx]` åŒºåŸŸï¼Œè¦†ç›–é»˜è®¤é…ç½®çš„å­é›†ã€‚

crate å®˜æ–¹æ³¨å†Œè¡¨ï¼š`https://crates.io` 

- ç™»å½•è´¦å·ï¼šcargo login [token]
- å‘å¸ƒï¼šcargo publish ï¼ˆä¸€æ—¦å‘å¸ƒï¼Œè¯¥ç‰ˆæœ¬ä»£ç æ— æ³•è¦†ç›–ï¼Œæ— æ³•åˆ é™¤ï¼‰
- æ’¤å›ä¸€ä¸ªç‰ˆæœ¬ï¼šcargo yank --vers 1.0.1 
- å–æ¶ˆæ’¤å›ï¼šcargo yank --vers 1.0.1 --undo
- å®‰è£…äºŒè¿›åˆ¶ crateï¼šcargo install

æ–‡æ¡£æ³¨é‡Šï¼šç”ŸæˆHTMLæ–‡æ¡£ï¼›ä½¿ç”¨ `///` ï¼›æ”¯æŒ Markdown

- `cargo doc`ã€`cargo dock --open`ï¼šç”Ÿæˆåœ¨ `target/doc` ç›®å½•ä¸‹
- å¸¸ç”¨ç« èŠ‚ï¼š
	- `# Examples`ï¼šcargo test å¯ä»¥æŠŠæ–‡æ¡£æ³¨é‡Šä¸­çš„ç¤ºä¾‹ä»£ç ä½œä¸ºæµ‹è¯•æ¥è¿è¡Œ
	- `# Panics`ï¼šå‡½æ•°å¯èƒ½å‘ç”Ÿ panic 
	- `# Errors`ï¼šå¦‚æœå‡½æ•°è¿”å› Resultï¼Œæè¿°å¯èƒ½çš„é”™è¯¯ç§ç±»ï¼Œä»¥åŠå¯å¯¼è‡´é”™è¯¯çš„æ¡ä»¶
	- `# Safety`ï¼šå¦‚æœå‡½æ•°å¤„äº unsafe è°ƒç”¨ï¼Œå°±åº”è¯¥è§£é‡Šå‡½æ•° unsafe çš„åŸå› ï¼Œä»¥åŠè°ƒç”¨è€…ç¡®ä¿çš„ä½¿ç”¨å‰æ

å¦‚æœæ˜¯æè¿° crate å’Œæ¨¡å—çš„æ³¨é‡Šï¼Œæˆ–è®°å½•ä¸€ä¸ªæ¨¡å—æ•´ä½“ï¼Œä½¿ç”¨ `//!`

ä½¿ç”¨ `pub use` å¯¼å‡ºæ–¹ä¾¿ä½¿ç”¨çš„å…¬å…± API

å·¥ä½œç©ºé—´ï¼š

- ç®¡ç†å¤šä¸ªå…³è”ä¸”éœ€ååŒå¼€å‘çš„crate
- å°±æ˜¯ä¸€å¥—å…±äº«åŒä¸€ä¸ª Cargo.lock å’Œè¾“å‡ºæ–‡ä»¶å¤¹çš„åŒ…
- å·¥ä½œç©ºé—´å†…æ‰€æœ‰crateä½¿ç”¨çš„ä¾èµ–çš„ç‰ˆæœ¬éƒ½æ˜¯ç›¸åŒçš„

è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• cargoï¼š

- cargo install
- äºŒè¿›åˆ¶ cargo-abcï¼›è¿è¡Œå‘½ä»¤`cargo abc`
- cargo --list

## 22. æ™ºèƒ½æŒ‡é’ˆ

- æ™ºèƒ½æŒ‡é’ˆï¼šè¡Œä¸ºè·ŸæŒ‡é’ˆç±»ä¼¼ï¼›æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½ï¼›
- å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆï¼š
	1. é€šè¿‡è®°å½•æ‰€æœ‰è€…çš„æ•°é‡ï¼Œä½¿ä¸€ä»½æ•°æ®è¢«å¤šä¸ªæ‰€æœ‰è€…åŒæ—¶æŒæœ‰
	2. åœ¨æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è‡ªåŠ¨æ¸…ç†æ•°æ®
- å®ç°æ™ºèƒ½æŒ‡é’ˆï¼š
	1. é€šå¸¸ä½¿ç”¨ struct å®ç°ï¼Œä¸”å®ç°äº† `Deref` å’Œ `Drop` è¿™ä¸¤ä¸ª trait
	2. `Deref trait`ï¼šå…è®¸æ™ºèƒ½æŒ‡é’ˆ struct çš„å®ä¾‹åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨
	3. `Drop trait`ï¼šå…è®¸ä½ è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆå®ä¾‹èµ°å‡ºä½œç”¨åŸŸæ—¶çš„ä»£ç 

æ¯”å¦‚ï¼š`String` å’Œ `Vec<T>` å°±æ˜¯æ™ºèƒ½æŒ‡é’ˆã€‚

### 22.1. `Box<T>`

`Box<T>`æ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆï¼š

- åœ¨heapä¸Šå­˜å‚¨æ•°æ®
- åœ¨stackä¸Šå­˜å‚¨æŒ‡å‘heapæ•°æ®çš„æŒ‡é’ˆ
- æ²¡æœ‰æ€§èƒ½å¼€é”€å’Œå…¶ä»–é¢å¤–åŠŸèƒ½
- å®ç°äº†`Deref` å’Œ `Drop` ä¸¤ä¸ª trait

![Box](images/Box.png)

ä½¿ç”¨åœºæ™¯ï¼š

- åœ¨ç¼–è¯‘æ—¶ï¼ŒæŸç±»å‹çš„å¤§å°æ— æ³•ç¡®å®šã€‚ä½†ä½¿ç”¨è¯¥ç±»å‹æ—¶ï¼Œä¸Šä¸‹æ–‡å´éœ€è¦çŸ¥é“å®ƒçš„ç¡®åˆ‡å¤§å°ã€‚
- å½“æœ‰å¤§é‡æ•°æ®ï¼Œæƒ³ç§»äº¤æ‰€æœ‰æƒï¼Œä½†éœ€è¦ç¡®ä¿åœ¨æ“ä½œæ—¶æ•°æ®ä¸ä¼šè¢«å¤åˆ¶ã€‚
- ä½¿ç”¨æŸä¸ªå€¼æ—¶ï¼Œä½ åªå…³å¿ƒå®ƒæ˜¯å¦å®ç°äº†ç‰¹å®šçš„ traitï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å…·ä½“ç±»å‹ã€‚

```rust
let b = Box::new(5);
println!("b = {}", b);

enum List {
    Cons(i32, Box<List>),
    Nil,
}
let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
```

### 22.2. Deref Trait

å®ç° Deref Traitï¼š

- ä½¿æˆ‘ä»¬å¯ä»¥**è‡ªå®šä¹‰è§£å¼•ç”¨è¿ç®—ç¬¦ `*` çš„è¡Œä¸º**
- ä½¿å¾—æ™ºèƒ½æŒ‡é’ˆå¯åƒå¸¸è§„å¼•ç”¨ä¸€æ ·æ¥å¤„ç†
- è¦æ±‚ï¼š**å®ç°ä¸€ä¸ª `deref` æ–¹æ³•**
	1. **è¯¥æ–¹æ³•å€Ÿç”¨ `self`**
	2. **è¿”å›ä¸€ä¸ªæŒ‡å‘å†…éƒ¨æ•°æ®çš„å¼•ç”¨**

`Box<T>` è¢«å®šä¹‰æˆæ‹¥æœ‰ä¸€ä¸ªå…ƒç´ çš„ `tuple struct`

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y); // ç›¸å½“äº *(y.deref())
}
```

å‡½æ•°å’Œæ–¹æ³•çš„**éšå¼è§£å¼•ç”¨è½¬åŒ–ï¼ˆDeref Coercionï¼‰**ï¼š

- Deref Coercion æ˜¯ä¸ºå‡½æ•°å’Œæ–¹æ³•æä¾›çš„ä¸€ç§ä¾¿æ·ç‰¹æ€§ï¼›
- å‡è®¾ T å®ç°äº†Deref Traitï¼Œé‚£ä¹ˆDeref Coercion å¯ä»¥æŠŠ **T çš„å¼•ç”¨** è½¬åŒ–ä¸º** T ç»è¿‡ Deref æ“ä½œåç”Ÿæˆçš„å¼•ç”¨**ï¼›
- å½“æŠŠæŸç±»å‹çš„å¼•ç”¨ä¼ é€’ç»™å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œä½†å®ƒçš„ç±»å‹å’Œå®šä¹‰çš„å‚æ•°ç±»å‹ä¸åŒ¹é…ï¼Œ**Deref Coercion å°±ä¼šè‡ªåŠ¨å‘ç”Ÿ**ï¼›**ç¼–è¯‘å™¨ä¼šå¯¹ deref è¿›è¡Œä¸€ç³»åˆ—è°ƒç”¨ï¼Œæ¥æŠŠå®ƒè½¬ä¸ºæ‰€éœ€çš„å‚æ•°ç±»å‹**ï¼›ï¼ˆæ²¡æœ‰é¢å¤–æ€§èƒ½å¼€é”€ï¼‰

```rust
fn hello(name: &str) {
    println!("Hello, {}", name)
}

let name = MyBox::new(String::from("Rust"));
hello(&name);
```

è§£å¼•ç”¨ä¸å¯å˜æ€§ï¼Œä¸‹é¢ä¸‰ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼ŒRust ä¼šæ‰§è¡Œ Deref Coercionï¼š

- å½“ `T: Dreft<Target=U>`ï¼Œå…è®¸ `&T` è½¬æ¢ä¸º `&U`
- å½“ `T: DreftMut<Target=U>`ï¼Œå…è®¸ `&mut T` è½¬æ¢ä¸º `&mut U`
- å½“ `T: Dreft<Target=U>`ï¼Œå…è®¸ `&mut T` è½¬æ¢ä¸º `&U`

### 22.3. Drop Trait

- è‡ªå®šä¹‰** å½“å€¼å°†è¦ç¦»å¼€ä½œç”¨åŸŸæ—¶å‘ç”Ÿçš„åŠ¨ä½œ**ï¼›
- ä»»ä½•ç±»å‹éƒ½å¯ä»¥å®ç° Drop Traitï¼›
- è¦æ±‚ï¼šå®ç° `drop` æ–¹æ³•ï¼Œå‚æ•°ä¸ºå¯¹ `self` çš„**å¯å˜å¼•ç”¨**ï¼›
- **ä¸å…è®¸æ˜¾ç¤ºçš„è°ƒç”¨ `drop` æ–¹æ³•**ï¼›ä½†å¯ä»¥è°ƒç”¨æ ‡å‡†åº“ä¸­çš„ **`std::mem::drop` å‡½æ•°**ï¼Œæ¥æå‰ drop å€¼ï¼›

```rust
struct SmartPointer {
    data: String,
}

impl Drop for SmartPointer {
    fn drop(&mut self) {
        println!("Dropping data {}", self.data);
    }
}

let p1 = SmartPointer {
    data: String::from("one"),
};
std::mem::drop(p1);
let p2 = SmartPointer {
    data: String::from("two"),
};
```

### 22.4. `Rc<T>`

- ä¸ºäº†æ”¯æŒå¤šé‡æ‰€æœ‰æƒï¼Œå¼•å…¥`Rc<T>`
- `Rc<T>` é€šè¿‡**ä¸å¯å˜å¼•ç”¨**ï¼Œä½¿å¾—åœ¨ç¨‹åºä¸åŒåœ°æ–¹å¯ä»¥å…±äº«åªè¯»æ•°æ®
- reference coutingï¼ˆå¼•ç”¨è®¡æ•°ï¼‰
- è¿½è¸ªæ‰€æœ‰åˆ°å€¼çš„å¼•ç”¨
- å½“0ä¸ªå¼•ç”¨æ—¶ï¼Œè¯¥å€¼å¯ä»¥è¢«æ¸…ç†æ‰
- `Rc::clone(&a)` å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œä¸ä¼šæ‰§è¡Œæ•°æ®çš„æ·±åº¦æ‹·è´
- `Rc::strong_count(&a)` è·å¾—å¼•ç”¨è®¡æ•°ï¼ˆå¼ºå¼•ç”¨ï¼‰
- `Rc::weak_count(&a)` è·å¾—å¼•ç”¨è®¡æ•°ï¼ˆå¼±å¼•ç”¨ï¼‰
- ä½¿ç”¨åœºæ™¯ï¼š
	1. éœ€è¦åœ¨heapä¸Šåˆ†é…æ•°æ®ï¼Œæ•°æ®è¢«ç¨‹åºçš„å¤šä¸ªåœ°æ–¹è¯»å–ï¼ˆåªè¯»ï¼‰ï¼Œä½†åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå“ªä¸ªéƒ¨åˆ†æœ€åä½¿ç”¨å®Œè¿™äº›æ•°æ®ï¼›
	2. åªèƒ½ç”¨äº**å•çº¿ç¨‹**åœºæ™¯

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));

    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));

    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

### 22.5. `RefCell<T>`

å†…éƒ¨å¯å˜æ€§ï¼ˆinterior mutabilityï¼‰ï¼š**å¯å˜çš„å€Ÿç”¨ä¸€ä¸ªä¸å¯å˜çš„å€¼**ã€‚Rustè®¾è®¡æ¨¡å¼ä¹‹ä¸€ï¼Œå®ƒ**å…è®¸ä½ åœ¨åªæŒæœ‰ä¸å¯å˜å¼•ç”¨çš„å‰æä¸‹å¯¹æ•°æ®è¿›è¡Œä¿®æ”¹**ã€‚ï¼ˆæ•°æ®ç»“æ„ä¸­ä½¿ç”¨äº† unsafe ä»£ç æ¥ç»•è¿‡ Rust æ­£å¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™ï¼‰

- `RefCell<T>` ç±»å‹ä»£è¡¨äº†å…¶æŒæœ‰æ•°æ®çš„å”¯ä¸€æ‰€æœ‰æƒ
- åªèƒ½ç”¨äº**å•çº¿ç¨‹**åœºæ™¯
- `RefCell<T>` ä¼šè®°å½•å½“å‰å­˜åœ¨å¤šå°‘ä¸ªæ´»è·ƒçš„`Ref<T>`å’Œ`RefMut<T>`æ™ºèƒ½æŒ‡é’ˆ
- `borrow`æ–¹æ³•ï¼šè¿”å›æ™ºèƒ½æŒ‡é’ˆ `Ref<T>`ï¼Œå®ƒå®ç°äº†Deref
	- æ¯æ¬¡è°ƒç”¨ï¼Œä¸å¯å˜å€Ÿç”¨è®¡æ•°åŠ  1ï¼›
	- ä»»ä½•ä¸€ä¸ª`Ref<T>`çš„å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¸å¯å˜å€Ÿç”¨è®¡æ•°å‡ 1ï¼›
- `borrow_mut`æ–¹æ³•ï¼šè¿”å›æ™ºèƒ½æŒ‡é’ˆ `RefMut<T>`ï¼Œå®ƒå®ç°äº†Deref
	- æ¯æ¬¡è°ƒç”¨ï¼Œå¯å˜å€Ÿç”¨è®¡æ•°åŠ  1ï¼›
	- ä»»ä½•ä¸€ä¸ª`RefMut<T>`çš„å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå¯å˜å€Ÿç”¨è®¡æ•°å‡ 1ï¼›
- å…¶ä»–å¯å®ç°å†…éƒ¨å¯å˜æ€§çš„ç±»å‹ï¼š
	- `Cell<T>`ï¼šé€šè¿‡å¤åˆ¶æ¥è®¿é—®æ•°æ®
	- `Mutex<T>`ï¼šç”¨äºå®ç°è·¨çº¿ç¨‹æƒ…å½¢ä¸‹çš„å†…éƒ¨å¯å˜æ€§æ¨¡å¼

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

fn main() {
    let value = Rc::new(RefCell::new(5));
    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a = {:?}", a);
    println!("b = {:?}", b);
    println!("c = {:?}", c);
}
```

### 22.6. `Box<T> vs Rc<T> vs RefCell<T>`

![box_vs_rc_vs_refcell](images/box_vs_rc_vs_refcell.png)

### 22.7. å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼

ä½¿ç”¨`Rc<T>`å’Œ`RefCell<T>`å¯ä»¥åˆ›é€ å‡ºå¾ªç¯å¼•ç”¨ï¼Œä»è€Œå‘ç”Ÿå†…å­˜æ³„æ¼ï¼›ï¼ˆæ¯ä¸ªé¡¹çš„å¼•ç”¨æ•°é‡ä¸ä¼šå˜æˆ0ï¼Œå€¼ä¸ä¼šè¢«æ¸…ç†æ‰ï¼‰

é˜²æ­¢å†…å­˜æ³„æ¼çš„è§£å†³æ–¹æ³•ï¼š

- ä¾é å¼€å‘è€…ä¿è¯ï¼›
- é‡æ–°ç»„ç»‡æ•°æ®ç»“æ„ï¼šä¸€äº›å¼•ç”¨æ¥è¡¨è¾¾æ‰€æœ‰æƒï¼Œä¸€äº›å¼•ç”¨ä¸è¡¨è¾¾æ‰€æœ‰æƒ
- **æŠŠ`Rc<T>`æ¢æˆ`Weak<T>`**
	- `Rc<T>`çš„å®ä¾‹åªæœ‰åœ¨ strong_count ä¸º 0 æ—¶æ‰ä¼šè¢«æ¸…ç†ï¼›
	- `Rc<T>`ä½¿ç”¨ weak_count æ¥è¿½è¸ªå­˜åœ¨å¤šå°‘`Weak<T>`ï¼Œ**weak_countä¸ä¸º0å¹¶ä¸å½±å“`Rc<T>`å®ä¾‹çš„æ¸…ç†**ï¼›

å¼ºå¼±å¼•ç”¨ï¼š

- Stong Referenceï¼ˆå¼ºå¼•ç”¨ï¼‰æ˜¯å…³äºå¦‚ä½•åˆ†äº« `Rc<T>`å®ä¾‹çš„æ‰€æœ‰æƒï¼›
- Weak Referenceï¼ˆå¼±å¼•ç”¨ï¼‰å¹¶ä¸ä¼šåˆ›å»ºå¾ªç¯å¼•ç”¨ï¼Œå½“Stong Referenceæ•°é‡ä¸º0æ—¶ï¼ŒWeak Referenceä¼šè‡ªåŠ¨æ–­å¼€ï¼›
- åœ¨ä½¿ç”¨`Weak<T>`å‰ï¼Œéœ€è¦ä¿è¯å®ƒæŒ‡å‘çš„å€¼ä»ç„¶å­˜åœ¨ï¼›ï¼ˆåœ¨`Weak<T>`å®ä¾‹ä¸Šè°ƒç”¨ upgrade æ–¹æ³•ï¼Œè¿”å›`Option<Rc<T>>`ï¼‰

```rust
#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf:   strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf)
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);
        println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

        println!(
            "leaf:   strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf)
        );
        println!(
            "branch: strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch)
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf:   strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf)
    );
}
```

## 23. å¹¶å‘

çº¿ç¨‹æ¨¡å‹ï¼š

- è°ƒç”¨OSçš„APIæ¥åˆ›å»ºçº¿ç¨‹ï¼š1:1æ¨¡å‹
- è¯­è¨€è‡ªå·±å®ç°çš„çº¿ç¨‹ï¼ˆç»¿è‰²çº¿ç¨‹ï¼‰ï¼šM:Næ¨¡å‹

Rust æ ‡å‡†åº“ä»…æä¾› 1:1 æ¨¡å‹çš„çº¿ç¨‹ã€‚ï¼ˆç¬¬ä¸‰æ–¹åŒ…ä¼šæœ‰M:Næ¨¡å‹ï¼‰

åˆ›å»ºæ–°çº¿ç¨‹ï¼š

- **`thread::spawn`**ï¼Œå‚æ•°ä¸ºä¸€ä¸ªé—­åŒ…
- **`move`** é—­åŒ…ï¼ŒæŠŠå€¼çš„æ‰€æœ‰æƒä»ä¸€ä¸ªçº¿ç¨‹è½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹

```rust
let v = vec![1, 2, 3];
let handle = thread::spawn(move || {
    println!("vector {:?}", v);
});
handle.join().unwrap();
```

**æ¶ˆæ¯ä¼ é€’ï¼š**

- **`channel`**ï¼šåŒ…å«å‘é€ç«¯å’Œæ¥æ”¶ç«¯ï¼›
- å¦‚æœå‘é€ç«¯ã€æ¥æ”¶ç«¯ä¸­ä»»æ„ä¸€ç«¯è¢«ä¸¢å¼ƒäº†ï¼Œé‚£ä¹ˆ channel å°± å…³é—­ äº†ï¼›
- **`mpsc::channel`**ï¼Œåˆ›å»º channelï¼Œè¿”å›ä¸€ä¸ª tupleï¼Œé‡Œé¢å…ƒç´ åˆ†åˆ«æ˜¯å‘é€ç«¯å’Œæ¥æ”¶ç«¯ï¼›
	- `mpsc`è¡¨ç¤º multiple producer, single consumerï¼ˆå¤šä¸ªç”Ÿäº§è€…ï¼Œä¸€ä¸ªæ¶ˆè´¹è€…ï¼‰
- **`recv`**ï¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ° channel æœ‰æ•°æ®åˆ°æ¥ï¼›
	- è¿”å› `Result<T, E>`ï¼Œå½“å‘é€ç«¯å…³é—­ï¼Œå°±ä¼šæ”¶åˆ°ä¸€ä¸ªé”™è¯¯ï¼›
- **`try_recv`**ï¼šä¸ä¼šé˜»å¡ï¼Œç«‹å³è¿”å› `Result<T, E>`
	- æœ‰æ•°æ®åˆ°æ¥ï¼Œè¿”å› Okï¼Œé‡Œé¢åŒ…å«ç€æ•°æ®ï¼›
	- å¦åˆ™ï¼Œè¿”å›é”™è¯¯
- **`mpsc::Sender::clone(&tx)`**ï¼šå¯ä»¥é€šè¿‡ clone åˆ›å»ºå¤šä¸ªå‘é€è€…

```rust
let (tx, rx) = mpsc::channel();

thread::spawn(move || {
    tx.send(String::from("one")).unwrap();
    tx.send(String::from("two")).unwrap();
    tx.send(String::from("three")).unwrap();
});

for received in rx {
    println!("Got {}", received);
}
```

**å…±äº«çŠ¶æ€ï¼š**

- Rust æ”¯æŒé€šè¿‡å…±äº«çŠ¶æ€æ¥å®ç°å¹¶å‘ï¼›
- channel ç±»ä¼¼å•æ‰€æœ‰æƒï¼Œä¸€æ—¦å°†å€¼çš„æ‰€æœ‰æƒè½¬ç§»è‡³ channelï¼Œå°±æ— æ³•ä½¿ç”¨å®ƒäº†ï¼›
- å…±äº«å†…å­˜å¹¶å‘ç±»ä¼¼å¤šæ‰€æœ‰æƒï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®åŒä¸€å—å†…å­˜ï¼›
- **`mutex`ï¼šé€šè¿‡é”å®šç³»ç»Ÿæ¥ä¿æŠ¤å®ƒæ‰€æŒæœ‰çš„æ•°æ®ã€‚**`mutual exclusion`ï¼ˆäº’æ–¥é”ï¼‰
	- `Mutex::new`ï¼šè¿”å›`Mutex<T>`;
	- `lock`ï¼šä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œè¿”å›`MutexGuard`ï¼ˆå®ç°äº†Derefå’ŒDropï¼‰;
	- `Mutex<T>`æä¾›äº†å†…éƒ¨å¯å˜æ€§ï¼Œå’Œ Cell å®¶æ—ä¸€æ ·ï¼›
- **`Arc<T>`**ï¼šä¸`Rc<T>`ä¸åŒçš„æ˜¯ï¼Œ`Arc<T>`ç”¨äºå¹¶å‘åœºæ™¯ï¼Œå¯è¿›è¡ŒåŸå­å¼•ç”¨è®¡æ•°ï¼›
	- å¯ä»¥ä½¿ç”¨`RefCell<T>`æ¥æ”¹å˜`Rc<T>`é‡Œé¢çš„å†…å®¹ï¼›
	- å¯ä»¥ä½¿ç”¨`Mutex<T>`æ¥æ”¹å˜`Arc<T>`é‡Œé¢çš„å†…å®¹ï¼›
- é£é™©ï¼š
	- `Rc<T>`å’Œ`RefCell<T>`ä½¿ç”¨å¯èƒ½æœ‰å†…å­˜æ³„æ¼çš„é£é™©ï¼›
	- `Mutex<T>`ä¹Ÿæœ‰æ­»é”çš„é£é™©ï¼›

```rust
let c = Arc::new(Mutex::new(0));
let mut handles = vec![];

for _ in 0..10 {
    let cc = Arc::clone(&c);
    let handle = thread::spawn(move || {
        let mut num = cc.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *c.lock().unwrap());
```

**æ‰©å±•å¹¶å‘**ï¼š

- ä¸¤ä¸ª Traitï¼š`std::marker::Sync`å’Œ`std::marker::Send`ï¼›
- **`Send`ï¼šå®ç°äº†`Send` traitçš„ç±»å‹å¯åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒï¼›**
	- `Rc<T>`æ²¡æœ‰å®ç° Sendï¼Œæ‰€ä»¥åªç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼›
- **`Sync`ï¼šå®ç°äº†`Sync` traitçš„ç±»å‹å¯ä»¥å®‰å…¨çš„è¢«å¤šä¸ªçº¿ç¨‹å¼•ç”¨ï¼›**
	- åŸºç¡€ç±»å‹éƒ½æ˜¯ Sync çš„ï¼›
	- å®Œå…¨ç”± Sync ç±»å‹ç»„æˆçš„ç±»å‹ä¹Ÿæ˜¯ Sync çš„ï¼›
	- `Rc<T>`ã€`RefCell<T>`ã€`Cell<T>`ä¸æ˜¯Syncçš„ï¼›
	- `Mutex<T>` æ˜¯ Syncçš„ï¼›
- **æ‰‹åŠ¨å®ç°`Send`å’Œ`Sync`æ˜¯ä¸å®‰å…¨çš„ï¼›**

## 24. é¢å‘å¯¹è±¡

- Rustæ˜¯é¢å‘å¯¹è±¡çš„ï¼›
	- structã€enumåŒ…å«æ•°æ®ï¼›implå—ä¸ºä¹‹æä¾›æ–¹æ³•ï¼›
- å°è£…ï¼šRusté‡Œæä¾› **pub å…³é”®å­—** æ¥å†³å®šä»£ç æ˜¯å¦å…¬å¼€ï¼›
- ç»§æ‰¿ï¼šRustæ²¡æœ‰ç»§æ‰¿ï¼›
	- ä»£ç å¤ç”¨ï¼šRusté€šè¿‡ **é»˜è®¤ trait æ–¹æ³•** æ¥è¿›è¡Œä»£ç å…±äº«ï¼›
	- å¤šæ€ï¼šRusté€šè¿‡ **æ³›å‹å’Œtraitçº¦æŸ** æ¥å®ç°å¤šæ€ï¼›
- ä½¿ç”¨ trait å¯¹è±¡ï¼Œæ‰§è¡Œçš„æ˜¯åŠ¨æ€æ´¾å‘ï¼ˆdynamic dispatchï¼‰ï¼Œä¼šäº§ç”Ÿè¿è¡Œæ—¶å¼€é”€ï¼›
- trait å¯¹è±¡å¿…é¡»ä¿è¯å¯¹è±¡å®‰å…¨ï¼ŒRustæœ‰ä¸€ç³»åˆ—è§„åˆ™æ¥åˆ¤å®šå¯¹è±¡æ˜¯å¦å®‰å…¨ï¼š
	- æ–¹æ³•çš„è¿”å›ç±»å‹ä¸æ˜¯ Self
	- æ–¹æ³•ä¸­ä¸åŒ…å«ä»»ä½•æ³›å‹ç±»å‹å‚æ•°

## 25. æ¨¡å¼

Rustä¸­çš„ä¸€ç§ç‰¹æ®Šè¯­æ³•ï¼Œç”¨äºåŒ¹é…å¤æ‚å’Œç®€å•ç±»å‹çš„ç»“æ„ã€‚æ¨¡å¼ç”±ä»¥ä¸‹å…ƒç´ ç»„æˆï¼šå­—é¢å€¼ã€enumã€structã€tupleã€å˜é‡ã€é€šé…ç¬¦ã€å ä½ç¬¦ã€‚**æƒ³è¦ä½¿ç”¨æ¨¡å¼ï¼Œéœ€è¦å°†å…¶ä¸æŸä¸ªå€¼è¿›è¡Œæ¯”è¾ƒã€‚**

ä¸¾ä¾‹ï¼š`match`ã€`if let`ã€`while let`ã€`for (k, v)`ã€`let (x, y, z)`ã€å‡½æ•°å‚æ•°ç­‰

æ¨¡å¼æœ‰ä¸¤ç§å½¢å¼ï¼š

- **æ— å¯è¾©é©³çš„**ï¼šèƒ½åŒ¹é…ä»»ä½•å¯èƒ½ä¼ é€’çš„å€¼çš„æ¨¡å¼ï¼›æ¯”å¦‚`let x = 5`ã€‚
- **å¯è¾©é©³çš„ï¼ˆrufutableï¼‰**ï¼›æŸäº›æƒ…å†µï¼Œæ— æ³•è¿›è¡ŒåŒ¹é…çš„æ¨¡å¼ï¼›æ¯”å¦‚`if let Some(x) = a`ï¼ˆaå¯èƒ½ä¸ºç©ºï¼‰ã€‚

- `å‡½æ•°å‚æ•°`ã€`let è¯­å¥`ã€`for å¾ªç¯` åªæ¥å—æ— å¯è¾©é©³çš„æ¨¡å¼ï¼›
- `if let`ã€`while let` æ¥å—å¯è¾©é©³å’Œæ— å¯è¾©é©³çš„æ¨¡å¼ï¼›

æ¨¡å¼ä½¿ç”¨è¯­æ³•ï¼š

1. åŒ¹é…å­—é¢å€¼
2. åŒ¹é…å‘½åå˜é‡
3. å¤šé‡æ¨¡å¼
4. ä½¿ç”¨..=åŒ¹é…æŸä¸ªèŒƒå›´çš„å€¼
5. è§£æ„structã€enumã€tupleï¼Œæ¥å¾—åˆ°å€¼
6. åœ¨æ¨¡å¼ä¸­å¿½ç•¥å€¼
7. åœ¨æ¨¡å¼ä¸­ä½¿ç”¨match guardï¼ˆmatchå®ˆå«ï¼‰
8. ä½¿ç”¨@ç»‘å®šï¼Œå¯ä»¥åœ¨æµ‹è¯•æŸä¸ªå€¼æ˜¯å¦ä¸æ¨¡å¼åŒ¹é…çš„åŒæ—¶ï¼Œä¿å­˜å€¼åˆ°å˜é‡ä¸­

```rust
fn main() {
    // 1. åŒ¹é…å­—é¢å€¼
    let x = 1;

    match x {
        1 => println!("one"),
        _ => println!("any"),
    }

    // 2. åŒ¹é…å‘½åå˜é‡
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {}", y), // è¿™é‡Œè¡¨ç¤ºåŒ¹é…ä»»ä½•å€¼ï¼Œyæ˜¯ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œç»‘å®šåˆ°è¢«SomeåŒ…è£¹çš„ä»»ä½•å€¼
        _ => println!("any"),
    }

    // 3. å¤šé‡æ¨¡å¼
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        _ => println!("anything"),
    }

    // 4. ä½¿ç”¨..=åŒ¹é…æŸä¸ªèŒƒå›´çš„å€¼
    let x = 5;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }

    // 5. è§£æ„structã€enumã€tupleï¼Œæ¥å¾—åˆ°å€¼
    struct Point {
        x: i32,
        y: i32,
    }
    let p = Point { x: 0, y: 7 };
    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => println!("On neither axis: ({x}, {y})"),
    }

    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }
    let msg = Message::ChangeColor(0, 160, 255);
    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) => {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {r}, green {g}, and blue {b}",)
        }
    }

    enum Color {
        Rgb(i32, i32, i32),
        Hsv(i32, i32, i32),
    }
    enum Message2 {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(Color),
    }
    let msg = Message2::ChangeColor(Color::Hsv(0, 160, 255));
    match msg {
        Message2::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message2::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change color to hue {h}, saturation {s}, value {v}")
        }
        _ => (),
    }

    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });

    // 6. åœ¨æ¨¡å¼ä¸­å¿½ç•¥å€¼
    fn foo(_: i32, y: i32) {
        println!("This code only uses the y parameter: {}", y);
    }
    foo(3, 4);

    let mut setting_value = Some(5);
    let new_setting_value = Some(10);
    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }
    println!("setting is {:?}", setting_value);

    let _x = 5; // å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡
    let y = 10;

    struct Point2 {
        x: i32,
        y: i32,
        z: i32,
    }
    let origin = Point2 { x: 0, y: 0, z: 0 };
    match origin {
        // ä½¿ç”¨ .. æ¥å¿½ç•¥å€¼çš„å‰©ä½™éƒ¨åˆ†
        Point2 { x, .. } => println!("x is {}", x),
    }

    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        (first, .., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }

    // 7. åœ¨æ¨¡å¼ä¸­ä½¿ç”¨match guardï¼ˆmatchå®ˆå«ï¼‰
    let num = Some(4);
    match num {
        Some(x) if x % 2 == 0 => println!("The number {} is even", x),
        Some(x) => println!("The number {} is odd", x),
        None => (),
    }

    // 8. ä½¿ç”¨@ç»‘å®šï¼Œå¯ä»¥åœ¨æµ‹è¯•æŸä¸ªå€¼æ˜¯å¦ä¸æ¨¡å¼åŒ¹é…çš„åŒæ—¶ï¼Œä¿å­˜å€¼åˆ°å˜é‡ä¸­
    enum Message3 {
        Hello { id: i32 },
    }
    let msg = Message3::Hello { id: 5 };
    match msg {
        Message3::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable),
        Message3::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        }
        Message3::Hello { id } => println!("Found some other id: {}", id),
    }
}
```

## 26. é«˜çº§ç‰¹æ€§

### 26.1. Unsafe

- `unsafe` å…³é”®å­—
- unsafeé‡Œå¯ä»¥æ‰§è¡Œå››ä¸ªåŠ¨ä½œï¼š
	1. è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
	2. è°ƒç”¨ unsafe å‡½æ•°æˆ–æ–¹æ³•
	3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡
	4. å®ç° unsafe trait
- æ³¨æ„ï¼š
	- unsafe å¹¶æ²¡æœ‰å…³é—­å€Ÿç”¨æ£€æŸ¥æˆ–åœç”¨å…¶ä»–å®‰å…¨æ£€æŸ¥
	- ä»»ä½•å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…é¡»ç•™åœ¨ unsafe å—é‡Œ
	- å°½å¯èƒ½éš”ç¦» unsafe ä»£ç ï¼Œæœ€å¥½å°†å…¶å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡é‡Œï¼Œæä¾›å®‰å…¨çš„API

åŸå§‹æŒ‡é’ˆï¼š

- **å¯å˜çš„ï¼š`*mut T`**
- **ä¸å¯å˜çš„ï¼š`*const T`**ã€‚è§£å¼•ç”¨åä¸èƒ½ç›´æ¥å¯¹å…¶è¿›è¡Œèµ‹å€¼ï¼›
- è¿™é‡Œ `*` ä¸æ˜¯è§£å¼•ç”¨ç¬¦å·ï¼Œå®ƒæ˜¯ç±»å‹åçš„ä¸€éƒ¨åˆ†ï¼›
- ä¸å¼•ç”¨ä¸åŒçš„æ˜¯ï¼ŒåŸå§‹æŒ‡é’ˆï¼š
	- å…è®¸é€šè¿‡åŒæ—¶å…·æœ‰ä¸å¯å˜å’Œå¯å˜æŒ‡é’ˆæˆ–å¤šä¸ªæŒ‡å‘åŒä¸€ä½ç½®çš„å¯å˜æŒ‡é’ˆæ¥å¿½ç•¥å€Ÿç”¨è§„åˆ™ï¼›
	- æ— æ³•ä¿è¯èƒ½æŒ‡å‘åˆç†çš„å†…å­˜ï¼›
	- å…è®¸ä¸ºnullï¼›
	- ä¸å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†ï¼›

```rust
fn main() {
    let mut num = 5;
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }

    unsafe fn dangerous() {}
    unsafe {
        dangerous();
    }

    let address = 0x01234usize;
    let r = address as *mut i32;
    let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

è°ƒç”¨Cè¯­è¨€ä»£ç ï¼š

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

unsafe {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}
```

ä»å…¶ä»–è¯­è¨€è°ƒç”¨Rustå‡½æ•°ï¼š

```rust
// #[no_mangle] ç”¨æ¥é¿å…Ruståœ¨ç¼–è¯‘æ—¶æ”¹å˜å®ƒçš„åç§°
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡ï¼š

- å¸¸é‡ï¼šå…è®¸ä½¿ç”¨å®ƒä»¬çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œå¤åˆ¶ï¼›
- é™æ€å˜é‡ï¼šæœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œä½¿ç”¨æ—¶æ€»ä¼šè®¿é—®åŒæ ·çš„æ•°æ®ï¼›**é™æ€å˜é‡æ˜¯å¯å˜çš„ï¼Œè®¿é—®å’Œä¿®æ”¹é™æ€å˜é‡æ˜¯ä¸å®‰å…¨çš„ï¼›**

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

add_to_count(3);
unsafe {
    println!("COUNTER: {}", COUNTER);
}
```

å®ç° Unsafe Traitï¼š

```rust
unsafe trait Foo {
    // methods go here
}
unsafe impl Foo for i32 {
    // method implementations go here
}
```

è®¿é—®unionå­—æ®µæ˜¯ä¸å®‰å…¨çš„ï¼š

```rust
#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}

let u = MyUnion { f1: 1 };
unsafe {
    let f = u.f1;
}
```

### 26.2. é«˜çº§ Trait

#### 26.2.1. ä½¿ç”¨å…³è”ç±»å‹æ¥æŒ‡å®šå ä½ç±»å‹

å…³è”ç±»å‹ï¼ˆassociated typesï¼‰ç›¸æ¯”æ³›å‹çš„åŒºåˆ«ï¼š

1. å…³è”ç±»å‹æ— éœ€æ ‡æ³¨ç±»å‹ï¼›
2. å…³è”ç±»å‹åªèƒ½å®ç°ä¸€æ¬¡Traitï¼›

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

#### 26.2.2. é»˜è®¤æ³›å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½

`Rhs`ï¼ˆright hand sideï¼‰ï¼šé»˜è®¤æ³›å‹å‚æ•°ã€‚

```rust
// å½“å®ç°Add traitæ—¶ï¼Œæˆ‘ä»¬ä¸æŒ‡å®šä¸€ä¸ªå®é™…çš„å‚æ•°ç»™åˆ°Rhsï¼Œé‚£ä¹ˆRhsä¼šè¢«é»˜è®¤è®¾ç½®ä¸º Selfã€‚
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

#### 26.2.3. å®Œå…¨é™å®šè¯­æ³•ï¼ˆFully Qualified Syntaxï¼‰

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

- å¯ä»¥åœ¨ä»»ä½•è°ƒç”¨å‡½æ•°æˆ–æ–¹æ³•çš„åœ°æ–¹ä½¿ç”¨
- å…è®¸å¿½ç•¥é‚£äº›ä»å…¶ä»–ä¸Šä¸‹æ–‡èƒ½æ¨å¯¼å‡ºæ¥çš„éƒ¨åˆ†
- ä»…å½“Rustæ— æ³•åŒºåˆ†ä½ æœŸæœ›è°ƒç”¨å“ªä¸ªå…·ä½“å®ç°æ—¶ï¼Œæ‰éœ€è¦ä½¿ç”¨è¿™ç§è¯­æ³•

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

#### 26.2.4. supertrait

éœ€è¦åœ¨ä¸€ä¸ªtraitä¸­ä½¿ç”¨å…¶ä»–traitçš„åŠŸèƒ½

```rust
trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {}
}

impl OutlinePrint for Point {}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

#### 26.2.5. ä½¿ç”¨ newtype æ¨¡å¼åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ trait

```rust
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

### 26.3. é«˜çº§ç±»å‹

- ç±»å‹åˆ«åï¼š`type`
- Neverç±»å‹ï¼š`!`ã€‚ä¸è¿”å›å€¼ã€‚
- åŠ¨æ€å¤§å°çš„ç±»å‹ï¼ˆDynamically Sized Typesï¼ŒDSTï¼‰ï¼šè¿è¡Œæ—¶ç¡®å®šå¤§å°ã€‚str æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹ã€‚
- Rust æä¾›äº†ä¸€ä¸ª Sized trait æ¥ç¡®å®šä¸€ä¸ªç±»å‹çš„å¤§å°åœ¨ç¼–è¯‘æ—¶æ˜¯å¦å·²çŸ¥ï¼›
	- ç¼–è¯‘æ—¶å¯è®¡ç®—å‡ºå¤§å°çš„ç±»å‹ä¼šè‡ªåŠ¨å®ç°è¿™ä¸€ traitï¼›
	- Rustè¿˜ä¼šä¸ºæ¯ä¸€ä¸ªæ³›å‹å‡½æ•°éšå¼çš„æ·»åŠ Sizedçº¦æŸï¼›
- `?Sized`ï¼šé»˜è®¤æƒ…å†µä¸‹ï¼Œæ³›å‹å‡½æ•°åªèƒ½è¢«ç”¨äºç¼–è¯‘æ—¶å·²ç»çŸ¥é“å¤§å°çš„ç±»å‹ï¼Œå¯ä»¥é€šè¿‡ç‰¹æ®Šè¯­æ³•è§£é™¤è¿™ä¸€é™åˆ¶ï¼›

```rust
type Kilometers = i32;

type Thunk = Box<dyn Fn() + Send + 'static>;

fn generic<T>(t: T) {}
// è¢«éšå¼è½¬æ¢æˆå¦‚ä¸‹ï¼š
fn generic<T: Sized>(t: T) {}
// ?Sized è¡¨ç¤º T å¯èƒ½æ˜¯Sizedï¼Œä¹Ÿå¯èƒ½ä¸æ˜¯Sized
fn generic<T: ?Sized>(t: &T) {}
```

### 26.4. é«˜çº§å‡½æ•°å’Œé—­åŒ…

- `fn` æ˜¯ä¸€ä¸ªç±»å‹ï¼Œä¸æ˜¯ä¸€ä¸ª trait
- å‡½æ•°æŒ‡é’ˆå®ç°äº†å…¨éƒ¨ 3 ç§é—­åŒ… traitï¼ˆFnã€FnMutã€FnOnceï¼‰
	- æ€»æ˜¯å¯ä»¥æŠŠå‡½æ•°æŒ‡é’ˆç”¨ä½œå‚æ•°ä¼ é€’ç»™ä¸€ä¸ªæ¥æ”¶é—­åŒ…çš„å‡½æ•°ï¼›
	- æ‰€ä»¥ï¼Œå€¾å‘äºæ­é…é—­åŒ…traitçš„æ³›å‹æ¥ç¼–å†™å‡½æ•°ï¼šå¯ä»¥åŒæ—¶æ¥æ”¶é—­åŒ…å’Œæ™®é€šå‡½æ•°
- æŸäº›æƒ…å†µä¸‹ï¼Œåªæƒ³æ¥æ”¶ fn è€Œä¸æ¥æ”¶é—­åŒ…ï¼šæ¯”å¦‚ä¸å¤–éƒ¨ä¸æ”¯æŒé—­åŒ…çš„ä»£ç äº¤äº’çš„ C å‡½æ•°
- è¿”å›é—­åŒ…ï¼šæ— æ³•åœ¨å‡½æ•°ä¸­ç›´æ¥è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œå¯ä»¥å°†ä¸€ä¸ªå®ç°äº†traitçš„å…·ä½“ç±»å‹ä½œä¸ºè¿”å›å€¼ï¼›

```rust
fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

enum Status {
    Value(u32),
    Stop,
}
let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();

fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

### 26.5. å®

- ä½¿ç”¨ `macro_rules!` æ„å»ºçš„å£°æ˜å®
- 3 ç§è¿‡ç¨‹å®ï¼š
	- è‡ªå®šä¹‰æ´¾ç”Ÿå®ï¼›
	- å±æ€§å®ï¼Œåœ¨ä»»ä½•æ¡ç›®ä¸Šæ·»åŠ è‡ªå®šä¹‰å±æ€§ï¼›
	- å‡½æ•°å®ï¼Œçœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼›

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

// 1. è‡ªå®šä¹‰æ´¾ç”Ÿå®
#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {}

// 2. å±æ€§å®
#[route(GET, "/")]
fn index() {}
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {}

// 3. å‡½æ•°å®
let sql = sql!(SELECT * FROM posts WHERE id=1);
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {}
```
