# è¯­è¨€åŸºç¡€

## 1. å˜é‡ã€å¸¸é‡ã€éšè—

- **`let`** å…³é”®å­—ï¼šå£°æ˜å˜é‡ã€‚
	1. å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ `Immutable`
	2. åŠ ä¸Š**`mut`**ï¼Œä½¿å˜é‡å¯å˜

- **`const`** å…³é”®å­—ï¼šå£°æ˜å¸¸é‡ã€‚
	1. ä¸å¯ä»¥ç”¨ `mut`
	2. å¿…é¡»æ ‡æ³¨ç±»å‹
	3. å¯ä»¥å£°æ˜åœ¨ä»»ä½•ä½œç”¨åŸŸ
	4. åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼

- **`Shadowing`** ï¼šéšè—ã€‚
	1. å¯ä»¥ä½¿ç”¨ `let` å£°æ˜ åŒåæ–°å˜é‡ï¼Œæ–°çš„å˜é‡å°±ä¼š `shadow` ä¹‹å‰å£°æ˜çš„å˜é‡
	2. æ–°çš„å˜é‡ï¼Œç±»å‹å¯ä»¥ä¸ä¹‹å‰ä¸åŒ

## 2. æ•°æ®ç±»å‹ï¼šæ ‡é‡ç±»å‹ã€å¤åˆç±»å‹

- æ ‡é‡ç±»å‹ï¼š
	1. æ•´æ•°ï¼š`i8ã€u8ã€i16ã€u16ã€i32ã€u32ã€i64ã€u64ã€i128ã€u128ã€isizeã€usize`ã€‚é»˜è®¤ç±»å‹æ˜¯ `i32`
	> æ•´æ•°æº¢å‡ºï¼š
	> 	- debugç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼š panicï¼›
	> 	- releaseç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼šæ‰§è¡Œ â€œç¯ç»•â€ æ“ä½œï¼Œä¸ä¼španicï¼›
	3. æµ®ç‚¹ï¼š`f32ã€f64`ã€‚é»˜è®¤ç±»å‹æ˜¯ `f64`
	4. å¸ƒå°”ï¼š`bool`ï¼›å€¼ä¸º`trueã€false`ï¼›å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
	5. å­—ç¬¦ï¼š`char`ï¼›ä½¿ç”¨å•å¼•å·ï¼›å ç”¨**4ä¸ªå­—èŠ‚**å¤§å°ï¼›æ˜¯**Unicodeæ ‡é‡å€¼**

- å¤åˆç±»å‹ï¼š
	1. å…ƒç»„ï¼šæ”¯æŒå¤šä¸ªç±»å‹çš„å€¼æ”¾ä¸€èµ·ï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›`let tup: (i32, f64, char) = (1, 2.0, 'a');`
	2. æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›å­˜æ”¾åœ¨ **`stack`** ä¸Šï¼›`let arr: [i32; 3] = [1,2,3];`ï¼Œä½¿ç”¨å›ºå®šå€¼åˆå§‹åŒ–æ•°ç»„æ—¶ `let arr = [3; 5];`

## 3. å‡½æ•°

- è¯­å¥ï¼ˆstatementï¼‰ï¼šæ‰§è¡Œä¸€äº›åŠ¨ä½œçš„æŒ‡ä»¤
- è¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°ä½“ï¼šç”±ä¸€ç³»åˆ— `statement` ç»„æˆï¼Œå¯é€‰çš„ç”±ä¸€ä¸ª `expression` ç»“æŸï¼›
- è¿”å›å€¼ï¼š`->` ç¬¦å·åå£°æ˜å‡½æ•°è¿”å›å€¼ç±»å‹ï¼›é€šå¸¸æ˜¯å‡½æ•°ä½“ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼›æå‰è¿”å›éœ€ä½¿ç”¨ `return` å…³é”®å­—

## 4. æ§åˆ¶æµ

- `if else`ï¼šæ¡ä»¶å¿…é¡»æ˜¯ `bool` ç±»å‹
- `loop`
- `while`
- `for`ï¼šå®‰å…¨ã€ç®€æ´
- `Range`ï¼š`rev` å¯ä»¥åè½¬ `Range`ï¼Œ`for num in (1..4).rev()`
- `match`

## 5. æ‰€æœ‰æƒ

æ‰€æœ‰æƒæ˜¯ `Rust æœ€æ ¸å¿ƒ`çš„ç‰¹æ€§ï¼Œå®ƒä½¿å¾— `Rust` æ— éœ€ `GC` å°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ã€‚

æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› ï¼Œå°±æ˜¯ç®¡ç† `heap` æ•°æ®ï¼š

- è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `heap` çš„å“ªäº›æ•°æ®ï¼›
- æœ€å°åŒ– `heap` ä¸Šçš„é‡å¤æ•°æ®é‡ï¼›
- æ¸…ç† `heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³ï¼›

### 5.1. æ‰€æœ‰æƒè§„åˆ™

- æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…ï¼›
- æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼›
- å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤ï¼›

### 5.2. å†…å­˜å’Œåˆ†é…

- **å½“å˜é‡èµ°å‡ºä½œç”¨åŸŸæ—¶ï¼ŒRust ä¼šè‡ªåŠ¨è°ƒç”¨`drop`å‡½æ•°ï¼Œå°†å†…å­˜è¿˜ç»™æ“ä½œç³»ç»Ÿ**ï¼›

- **ç§»åŠ¨ï¼ˆMoveï¼‰**ï¼š
![move](images/move.png)

æŠŠ s1 èµ‹å€¼ç»™ s2 , ä¸ºäº†ä¿è¯å†…å­˜å®‰å…¨ï¼š

	Ruståªåœ¨ `stack` ä¸Šå¤åˆ¶ï¼Œæ²¡æœ‰åœ¨ `heap` ä¸Šå¤åˆ¶ï¼›
	Rustè®© s1 å¤±æ•ˆï¼›

å¦‚æœçœŸçš„æƒ³å¯¹ `heap` ä¸Šçš„æ•°æ®åš `æ·±åº¦æ‹·è´`ï¼Œå¯ä»¥ä½¿ç”¨ `clone` æ–¹æ³•ã€‚

- **å¤åˆ¶**ï¼š
	- å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy trait`ï¼Œé‚£ä¹ˆæ—§çš„å˜é‡åœ¨èµ‹å€¼åä»ç„¶å¯ç”¨ï¼›
	- å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`ï¼Œé‚£ä¹ˆ Rust ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`ï¼›

**ç®€å•è¯´ï¼Œstackä¸Šçš„èµ„æºæœ‰copy traitï¼Œheapä¸Šçš„èµ„æºæ²¡æœ‰copy traitã€‚**

ä¸€äº›æ‹¥æœ‰ Copy trait çš„ç±»å‹ï¼š

- æ ‡é‡ç±»å‹
- å…ƒç»„ï¼Œå‰ææ˜¯æ‰€æœ‰å­—æ®µéƒ½æ˜¯copyçš„

### 5.3. å‡½æ•°

- å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå°†å‘ç”Ÿ **ç§»åŠ¨** æˆ– **å¤åˆ¶**ï¼›
- å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­ï¼ŒåŒæ ·ä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»ï¼›

ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒï¼Œæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼ï¼š

- æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶ä»–å˜é‡æ—¶ï¼Œå°±ä¼šå‘ç”Ÿç§»åŠ¨ï¼›
- å½“ä¸€ä¸ªåŒ…å« `heap` æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†ï¼›

## 6. å¼•ç”¨å’Œå€Ÿç”¨

- å¼•ç”¨ï¼š`&`ç¬¦å·ï¼Œå…è®¸å¼•ç”¨æŸäº›å€¼è€Œ**ä¸å–å¾—å…¶æ‰€æœ‰æƒ**ï¼›é»˜è®¤ä¸å¯å˜çš„ï¼›
- å€Ÿç”¨ï¼šæŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°è¿™ä¸ªè¡Œä¸ºå«åšå€Ÿç”¨ï¼›`fn calc_len(s: & String) -> usize`
- å¯å˜å¼•ç”¨ï¼šæ¯”å¦‚`mut & String`ï¼›**åœ¨ç‰¹å®šä½œç”¨åŸŸå†…ï¼ŒæŸå—æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚ï¼ˆé¿å…ç«äº‰ï¼‰**ï¼›
	- ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å¯å˜å¼•ç”¨
	- å¯ä»¥åŒæ—¶æ‹¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨

## 7. åˆ‡ç‰‡ï¼ˆsliceï¼‰

åˆ‡ç‰‡ï¼ˆsliceï¼‰ï¼š`&str`ï¼Œä¹Ÿæ˜¯ä¸€ç§**ä¸æŒæœ‰æ‰€æœ‰æƒ**çš„æ•°æ®ç±»å‹ï¼›

- å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…ï¼›
- å¦‚æœå¯¹ä¸€ä¸ª**å¤šå­—èŠ‚çš„å­—ç¬¦**ä¸­åˆ›å»ºå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç¨‹åºæŠ¥é”™å¹¶é€€å‡ºï¼›

## 8. ç»“æ„ä½“ï¼ˆstructï¼‰

- ä¸€æ—¦ struct çš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„ï¼›

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User { // ä½œä¸ºå‡½æ•°è¿”å›å€¼
        active: true,
        username, // ç®€å†™
        email,    // ç®€å†™
        sign_in_count: 1,
    }
}

let u1 = build_user(String::from("joe@163.com"), String::from("joe"));

let u2 = User {
    email: String::from("tom@163.com"),
    username: String::from("tom"),
    ..u1   // struct æ›´æ–°è¯­æ³•
};

// Tuple struct
// structæœ‰åï¼Œä½†é‡Œé¢å…ƒç´ æ²¡å
struct Point(i32, i32, i32);
let origin = Point(4, 5, 6);

// Unit-Like struct
// æ²¡æœ‰ä»»ä½•å­—æ®µï¼Œé€‚ç”¨äºéœ€è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª traitï¼Œä½†é‡Œé¢æœ‰æ²¡æœ‰éœ€è¦å­˜å‚¨çš„æ•°æ®
struct Solution;
```

- **æ–¹æ³•**ï¼šåœ¨ `impl` å—å®šä¹‰æ–¹æ³•ï¼›æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯ `&self`ï¼Œä¹Ÿå¯ä»¥è·å¾—å…¶æ‰€æœ‰æƒ æˆ– å¯å˜å€Ÿç”¨ï¼›
- **å…³è”å‡½æ•°**ï¼šåœ¨ `impl` å—å®šä¹‰ï¼Œä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼›

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // å…³è”å‡½æ•°
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size
        }
    }
}
```

## 9. æšä¸¾ï¼ˆenumï¼‰

- å¯ä»¥å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­
- æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡
- ä½¿ç”¨`impl`ä¸ºæšä¸¾å®šä¹‰æ–¹æ³•

```rust
#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        println!("{:?}", self);
    }
}
```

Rust æä¾›äº†ç±»ä¼¼ `Null` æ¦‚å¿µçš„æšä¸¾ï¼š`Option<T>`

- `Option<T>` å’Œ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼›
- è‹¥éœ€è¦ä½¿ç”¨`Option<T>`ä¸­çš„`T`ï¼Œéœ€è¦å…ˆè½¬æ¢ï¼›

```rust
enum Option<T> {
    Some(T),
    None,
}
```

## 10. match

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- `æ¨¡å¼`å¯ä»¥æ˜¯å­—é¢å€¼ã€å˜é‡åã€é€šé…ç¬¦...
- æ¨¡å¼å¯ä»¥ç»‘å®šå€¼ï¼Œæ¯”å¦‚ä» enum å˜ä½“ä¸­æå–å€¼ï¼›
- match åŒ¹é…**å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½**ï¼›å¦‚æœä¸æƒ³å¤„ç†ï¼Œåˆ™ä½¿ç”¨ `_ é€šé…ç¬¦`æ¥æ›¿ä»£å…¶ä½™å€¼ï¼›

```rust
let x = Some(5);
match x {
    None => None,
    Some(i) => Some(i + 1),
}

let v = 0u8;
match v {
    1 => 1,
    3 => 3,
    5 => 5,
    _ => 999,
}
```

## 11. if let

- åª**å…³å¿ƒä¸€ç§åŒ¹é…**è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µï¼›
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½ï¼›

```rust
let x = Some(5);
if let Some(5) = x {
    println!("five")
} else {
	println!("others")
}
```

## 12. Packageã€Crateã€Moduleã€Path

- `Crate`ï¼š
	- ä¸¤ç§ç±»å‹ï¼š`binary`ã€`library`
	- `Crate Root`ï¼šæŒ‡æºä»£ç å…¥å£æ–‡ä»¶
		- `src/main.rs`  ( binary )
		- `src/lib.rs`  ( library )

- `Package`ï¼š
	- `Cargo.toml`ï¼šæè¿°äº†å¦‚æœæ„å»º `Crates`
	- åªèƒ½åŒ…å« `0-1` ä¸ª `library crate`
	- å¯ä»¥åŒ…å« `ä»»æ„æ•°é‡` çš„ `binary crate`
	- ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`

- `Module`ï¼šåœ¨ä¸€ä¸ª `crate` å†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
	- æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§ï¼ˆpublicã€privateï¼‰
	- **`mod`** å…³é”®å­—ï¼Œå¯åµŒå¥—

- `Path`ï¼š
	- ä¸¤ç§å½¢å¼ï¼šç»å¯¹è·¯å¾„ï¼ˆæ¨èï¼‰ã€ç›¸å¯¹è·¯å¾„
	- æ ‡è¯†ç¬¦ `::`
	- **`super`** å…³é”®å­—ï¼Œç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„`..`

- `privacy boundary`ï¼šç§æœ‰è¾¹ç•Œ
	- Rustä¸­æ‰€æœ‰æ¡ç›®ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€structã€enumã€æ¨¡å—ã€å¸¸é‡ï¼‰**é»˜è®¤æ˜¯ç§æœ‰çš„**ã€‚
	- çˆ¶æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—çš„ç§æœ‰æ¡ç›®
	- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
	- **`pub`** å…³é”®å­—æ ‡è®°æ¡ç›®ä¸ºå…¬å…±çš„

- **`pub struct`**ï¼š
	- `struct` æ˜¯å…¬å…±çš„ï¼Œä½†**é‡Œé¢çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„**
	- é‡Œé¢çš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½® `pub` æ¥å˜æˆå…¬æœ‰çš„

- **`pub enum`**ï¼š
	- `enum` æ˜¯å…¬å…±çš„ï¼Œ
	- **`enum` çš„å˜ä½“ä¹Ÿéƒ½æ˜¯å…¬å…±çš„**

- **`use`**ï¼šå°† `path` å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…ï¼Œï¼ˆä½œç”¨åŸŸå†…**ç§æœ‰**ï¼‰
	- å‡½æ•°ï¼šæƒ¯ç”¨åšæ³•æ˜¯å°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šçˆ¶çº§ï¼‰
	- `structã€enum`ï¼šæƒ¯ç”¨åšæ³•æŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šæœ¬çœï¼‰ï¼ˆé™¤éä¸¤ä¸ªæ¨¡å—ä¸­çš„ç»“æ„ä½“åç§°ç›¸åŒï¼‰
	- **`as`** å…³é”®å­—ï¼šå¯ä»¥ç»™å¼•å…¥è·¯å¾„æŒ‡å®šï¼ˆæœ¬åœ°ï¼‰åˆ«å
	- **`pub use`**ï¼šé‡æ–°å¯¼å‡ºåç§°
	- å¯ä»¥ä½¿ç”¨ **åµŒå¥—è·¯å¾„** æ¸…ç†å¤§é‡çš„ `use` è¯­å¥
	- æ”¯æŒé€šé…ç¬¦ `*`

```rust
// åµŒå¥—è·¯å¾„
use std::{cmp::Ordering, io}
use std::io::{self, Write}
```

- **å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶ä»–æ–‡ä»¶**
	- æ¨¡å—ååé¢æ˜¯ `;`
	- Rust ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹

## 13. Vectorã€Stringã€HashMap

- Vector

```rust
// Vector
let mut v: Vec<i32> = Vec::new();
let mut v1 = vec![1,2,3];
v.push(99);
v.get(0);
for item in  v {}
for (i, item) in v.iter().enumerate() {}

enum Cell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    Cell::Int(1),
    Cell::Float(2.34),
    Cell::Text(String::from("red")),
]
```

- Stringï¼š**å­—ç¬¦ä¸²åœ¨Rustä¸­ä½¿ç”¨ `UTF-8` ç¼–ç **
	- `String`  æ¥è‡ªæ ‡å‡†åº“
	- `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œæ¥è‡ªRustæ ¸å¿ƒè¯­è¨€
	- å…¶ä»–å­—ç¬¦ä¸²ç±»å‹ï¼š`OsStringã€OsStrã€CStringã€CStr`
	- **Rustä¸­å­—ç¬¦ä¸²ä¸æ”¯æŒç´¢å¼•è¯­æ³•è®¿é—®**ã€‚åŸå› ï¼š
		- 1. ä¸å®‰å…¨ï¼Œè¶Šç•Œé—®é¢˜ï¼›
		- 2. ç´¢å¼•æ“ä½œåº”æ¶ˆè€—O(1)ï¼Œä½†Stringæ— æ³•ä¿è¯è¿™ä¸ªæ—¶é—´ï¼Œå› ä¸ºéœ€è¦éå†æ‰€æœ‰å†…å®¹æ‰èƒ½ç¡®å®šæœ‰å¤šå°‘åˆæ³•å­—ç¬¦ï¼›
	- `String` æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…
	- Rustä¸­çœ‹å¾…å­—ç¬¦ä¸²æœ‰ä¸‰ç§æ–¹å¼ï¼š
		- å­—èŠ‚ï¼ˆBytesï¼‰
		- æ ‡é‡å€¼ï¼ˆScalar Valuesï¼‰
		- å­—å½¢ç°‡ï¼ˆGrapheme Clustersï¼‰
	- Rustä¸­ï¼Œ**å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„**ï¼ˆ**`1-4`ä¸ªå­—èŠ‚**ï¼‰
	- åˆ‡å‰²å­—ç¬¦ä¸²ï¼Œå¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œ**å¦‚æœè·¨è¶Šäº†å­—ç¬¦è¾¹ç•Œï¼Œç¨‹åºå°±ä¼španic**ã€‚

```rust
let blue = "Blue".to_string();
let mut red = String::from("Red");
red.push_str("black");
red.push_str(&blue);  // é™„åŠ å­—ç¬¦ä¸²åˆ‡ç‰‡
red.push('ğŸ˜‚');      // é™„åŠ å•ä¸ªå­—ç¬¦

let color = red + &blue; // fn add(self, s: &str) -> String
// æ³¨æ„ï¼šredå‘ç”Ÿäº†ç§»åŠ¨ï¼Œæ‰€æœ‰æƒè¿›è¡Œäº†è½¬ç§»ï¼Œåç»­æ— æ³•ç»§ç»­ä½¿ç”¨

let s = format!("{}-{}", "foo", "bar");

// å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç 
println!("{}", "a".len());  // æ‰“å° 1
println!("{}", "Ğ´".len());  // æ‰“å° 2
println!("{}", "à¤µ".len());  // æ‰“å° 3
println!("{}", "ğŸ˜‚".len()); // æ‰“å° 4

// éå†
for i in color.chars() {}  // æƒ³å¾—åˆ° æ ‡é‡å€¼
for i in color.bytes() {}  // æƒ³å¾—åˆ° å­—èŠ‚
```

- HashMap
	- åœ¨å…ƒç´ ç±»å‹ä¸º `Tuple`ï¼ˆä¸¤ä¸ªå€¼ï¼‰ çš„ `Vector` ä¸Šä½¿ç”¨ `collect`æ–¹æ³•ï¼Œå¯ä»¥ç»„å»ºä¸€ä¸ª `HashMap` 
	- **æ‰€æœ‰æƒ**ï¼š
		- **å¯¹äºå®ç°äº† `Copy trait` çš„ç±»å‹ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ã€‚**æ¯”å¦‚ `i32` 
		- **å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè½¬ç§»ç»™ `HashMap` ã€‚**æ¯”å¦‚ `String` 
		- å¦‚æœå°†**å€¼çš„å¼•ç”¨**æ’å…¥åˆ° `HashMap` ï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨ï¼›ä½†è¿™æœŸé—´å¿…é¡»ä¿æŒå¼•ç”¨çš„å€¼æœ‰æ•ˆ
	- **Hashå‡½æ•°**ï¼š
		- é»˜è®¤æƒ…å†µä¸‹çš„hashå‡½æ•°ï¼Œå¯ä»¥æŠµæŠ—Dosæ”»å‡»ï¼Œå®‰å…¨æ€§æ›´å¥½ï¼Œä½†ä¸æ˜¯æœ€å¿«çš„ç®—æ³•ï¼›
		- å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` ï¼ˆæŒ‡å®ç°äº† `BuildHasher trait` çš„ç±»å‹ï¼‰æ¥åˆ‡æ¢ï¼›

```rust
let mut map: HashMap<i32, String> = HashMap::new();
map.insert(10, String::from("red"));
let v = map.get(&10);
match v {
    None => println!("not exist"),
    Some(s) => println!("{}", s),
}

let color = vec![String::from("red"), String::from("blue")];
let nums = vec![100, 200];
let mut map: HashMap<_, _> = color.iter().zip(nums.iter()).collect();
for (k,v) in &map {
    println!("{}: {}", k, v)
}
map.entry(&String::from("black")).or_insert(&300); // keyä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥

let text = "hello world wonderful world";
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
println!("{:#?}", map);
// entryæ–¹æ³•ï¼šè¿”å› enum Entryï¼Œä»£è¡¨å€¼æ˜¯å¦å­˜åœ¨
// or_insertæ–¹æ³•ï¼š
//        å¦‚æœ key å­˜åœ¨ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
//        å¦‚æœ key ä¸å­˜åœ¨ï¼Œå°†æ–°é”®å€¼(k,v)æ’è¿›å»ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
```

## 14. é”™è¯¯å¤„ç†

- å¯æ¢å¤ï¼š`Result<T, E>`
- ä¸å¯æ¢å¤ï¼š`panic!` å®

**panicï¼š**

- é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ panic å‘ç”Ÿæ—¶ï¼Œç¨‹åºä¼š **å±•å¼€ï¼ˆunwindï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆRustæ²¿è°ƒç”¨æ ˆå¾€å›èµ°ï¼Œæ¸…ç†æ¯ä¸€ä¸ªé‡åˆ°çš„æ•°æ®ï¼‰
- æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼Œå¯ä»¥æŠŠè¿™ä¸€è¡Œä¸ºæ”¹ä¸º **ç«‹å³ä¸­æ­¢ï¼ˆabortï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆç”±OSè¿›è¡Œæ¸…ç†ï¼‰
	- åœ¨Cargo.tomlä¸­è®¾ç½®ï¼š
```toml
[profile.release]
panic = 'abort'
```
- å›æº¯ä¿¡æ¯ï¼šè®¾ç½®ç¯å¢ƒå˜é‡ `RUST_BACKTRACE`ï¼›debugæ¨¡å¼ï¼›

**Resultæšä¸¾ï¼š**

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**é”™è¯¯å¤„ç†ï¼š**

- **`match`**
- **`unwrap`**ï¼šmatchè¡¨è¾¾å¼çš„ä¸€ä¸ªå¿«æ·æ–¹å¼ï¼›
- **`expect`**ï¼šå¯æŒ‡å®šé”™è¯¯ä¿¡æ¯

```rust
let f = File::open("hello.ext").unwrap();
let f = File::open("hello.ext").expect("cannot open file");
```

**ä¼ æ’­é”™è¯¯ï¼š**

- **`?` è¿ç®—æ³•**ï¼šä¼ æ’­é”™è¯¯çš„å¿«æ·æ–¹å¼
- **`from` å‡½æ•°**ï¼šç”¨äºé”™è¯¯ä¹‹é—´çš„è½¬æ¢ï¼›åœºæ™¯ï¼šé’ˆå¯¹ä¸åŒçš„é”™è¯¯åŸå› ï¼Œè¿”å›åŒä¸€ç§é”™è¯¯ç±»å‹ï¼›
	- è¦æ±‚ï¼šæ¯ä¸ªé”™è¯¯ç±»å‹éƒ½å®ç°äº†è½¬æ¢ä¸ºæ‰€è¿”å›çš„é”™è¯¯ç±»å‹çš„fromå‡½æ•°ï¼›
- **`main` å‡½æ•°**çš„è¿”å›ç±»å‹æ˜¯ `()`ï¼Œ`main` å‡½æ•°çš„è¿”å›ç±»å‹ä¹Ÿå¯ä»¥æ˜¯ `Result<T, E>`
	- main è¿”å›ç±»å‹å†™ï¼š`Result<(), Box<dyn Error>>`
	- `Box<dyn Error>` æ˜¯ trait å¯¹è±¡ï¼Œè¡¨ç¤ºä»»ä½•å¯èƒ½çš„é”™è¯¯ç±»å‹ï¼›

```rust
fn open_file() -> Result<String, io::Error> {
    let f = File::open("hello.ext")?;
    Ok(String::from("ok"))
}

fn read_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.ext")?.read_to_string(&mut s)?;
    Ok(s)
}
```

## 15. æ³›å‹

- ä½¿ç”¨æ³›å‹çš„ä»£ç å’Œä½¿ç”¨å…·ä½“ç±»å‹çš„ä»£ç è¿è¡Œé€Ÿåº¦æ˜¯ä¸€æ ·çš„ã€‚
- å•æ€åŒ–ï¼ˆmonomorphizationï¼‰ï¼šåœ¨ç¼–è¯‘æ—¶å°†æ³›å‹æ›¿æ¢ä¸ºå…·ä½“ç±»å‹

```rust
// å‡½æ•°
fn largest<T>(list: &[T]) -> T {}

// ç»“æ„ä½“
struct Point<T, U> {
    x: T,
    y: U,
}

// æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// æ–¹æ³•
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {}
}
```

## 16. Trait

- ç±»ä¼¼`Interface`ï¼ŒæŠ½è±¡çš„å®šä¹‰å…±äº«è¡Œä¸º
- `Trait bounds`ï¼šæ³›å‹ç±»å‹å‚æ•°æŒ‡å®šä¸ºå®ç°äº†ç‰¹å®šè¡Œä¸ºçš„ç±»å‹
- `trait` å¯ä»¥æœ‰å¤šä¸ªæ–¹æ³•ï¼Œæ¯ä¸ªæ–¹æ³•ç­¾åå ä¸€è¡Œï¼›
- å®ç°è¯¥ `trait` çš„ç±»å‹å¿…é¡»æä¾›å…·ä½“çš„æ–¹æ³•å®ç°ï¼›
- å®ç° `trait` çš„çº¦æŸï¼š**è¿™ä¸ªç±»å‹ æˆ– è¿™ä¸ª trait æ˜¯åœ¨æœ¬åœ° `crate` é‡Œå®šä¹‰çš„**ï¼Œæ‰€ä»¥**æ— æ³•ä¸ºå¤–éƒ¨ç±»å‹æ¥å®ç°å¤–éƒ¨çš„ trait**ï¼›
- å¯ä»¥åœ¨ `trait` é‡Œé¢å®šä¹‰**é»˜è®¤å®ç°çš„æ–¹æ³•**ï¼›**é»˜è®¤å®ç°çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ trait ä¸­å…¶ä»–çš„æ–¹æ³•ï¼Œå³ä½¿è¿™ä¸ªæ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°**ï¼›
- **æ— æ³•ä»æ–¹æ³•çš„é‡å†™å®ç°é‡Œé¢è°ƒç”¨é»˜è®¤çš„å®ç°**ï¼›
- `trait` å¯ä»¥**ä½œä¸ºå‚æ•°**ï¼Œä¸‰ç§å†™æ³•ï¼š1. implã€2. trait boundã€3. trait bound where
- `trait` å¯ä»¥**ä½œä¸ºè¿”å›ç±»å‹**ï¼›
	- **`impl Trait` åªèƒ½è¿”å›ä¸€ç§ç¡®å®šçš„ç±»å‹**ï¼Œè¿”å›å¯èƒ½ä¸åŒçš„ç±»å‹ä¼šæŠ¥é”™ï¼›
- å¯ä»¥ä½¿ç”¨`Trait bound` **æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•**
- **è¦†ç›–å®ç°ï¼ˆblanket implementationsï¼‰**ï¼šå¯ä»¥ä¸ºæ»¡è¶³`Trait bounds`çš„æ‰€æœ‰ç±»å‹ä¸Šå®ç°`trait`

```rust
// å®šä¹‰ trait
pub trait Summary {
    fn summarize(&self) -> string;

    fn summarize_default(&self) -> string {
        format!("default {}", self.summarize())
    }
}

pub struct NewsArticle {...}

// å®ç° trait
impl Summary for NewsArticle {
    fn summarize(&self) -> string {
        format!("{}", "article")
    }
}

// trait ä½œä¸ºå‚æ•°
pub fn notify(item: impl Summary) {
    println!("news {}", item.summarize())
}
// è¦æ±‚ item å®ç°äº†å¤šä¸ª trait
pub fn notify1(item: impl Summary + Display) {
    println!("news {}", item.summarize())
}

// Trait bound å†™æ³•
pub fn notify<T: Summary + Display>(item1: T, item2: T) {
    println!("news {}", item.summarize())
}

// Trait bound ä½¿ç”¨ where
pub fn notify<T, U>(a: T, b: U) -> string
where
    T: Summary + Display,
    U: Clone + Debug,
{
    println!("news {}", item.summarize())
}

// trait ä½œä¸ºè¿”å›ç±»å‹
pub fn notify(s: &str) -> impl Summary {
    NewsArticle {...}
}

// Trait bound æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•
struct Pair<T> {
    x: T,
    y: T,
}
impl<T> Pair<T> {
    // æ‰€æœ‰çš„Pairç±»å‹ï¼Œéƒ½æœ‰newå‡½æ•°
    fn new(x: T, y: T) -> self{
        Self { x, y }
    }
}
impl<T: Display + PartialOrd> Pair<T> {
    // åªæœ‰å®ç°äº†(Display+PartialOrd)è¿™ä¸¤ä¸ªtraitçš„Pairç±»å‹ï¼Œæ‰æ‹¥æœ‰cmpå‡½æ•°
    fn cmp(&self) {...}
}

// æ ‡å‡†åº“ string.rs ä¸­ï¼Œä½¿ç”¨äº†è¦†ç›–å®ç°
// ä¸ºæ‰€æœ‰å®ç°äº†Displayè¿™ä¸ªtraitçš„ç±»å‹Tï¼Œå®ç°ToStringè¿™ä¸ªtrait
impl<T: Display> ToString for T {
    default fn to_string(&self) -> string {}
}
```

## 17. ç”Ÿå‘½å‘¨æœŸ

- Rust çš„æ¯ä¸ªå¼•ç”¨éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
- ç”Ÿå‘½å‘¨æœŸï¼šå¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸ
- å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯éšå¼çš„ã€å¯è¢«æ¨æ–­çš„ï¼›å½“æ— æ³•è¢«ç¼–è¯‘å™¨æ¨æ–­æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸ
- ç”Ÿå‘½å‘¨æœŸå­˜åœ¨çš„ä¸»è¦ç›®æ ‡ï¼šé¿å…æ‚¬å‚å¼•ç”¨ï¼ˆdangling referenceï¼‰
- å€Ÿç”¨æ£€æŸ¥å™¨ï¼šæ¯”è¾ƒä½œç”¨åŸŸæ¥åˆ¤æ–­æ‰€æœ‰çš„å€Ÿç”¨æ˜¯å¦åˆæ³•
- ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ä¸ä¼šæ”¹å˜å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿åº¦
- å½“æŒ‡å®šäº†æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œå‡½æ•°å¯ä»¥æ¥æ”¶å¸¦æœ‰ä»»ä½•ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
- ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨ï¼šæè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸçš„å…³ç³»ï¼Œä½†ä¸å½±å“ç”Ÿå‘½å‘¨æœŸ
- é™æ€ç”Ÿå‘½å‘¨æœŸï¼šæ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´ã€‚`let s: &'static str = "hello";`

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
	if x > y {
		x
	} else {
		y
	}
}

struct ImportantExcerpt<'a> {
	part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
	fn level(&self) -> i32 {
		3
	}
}

fn longest_with_an_annoucement<'a, T>
    (x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display,
{
	println!("Announcement! {}", ann)
	if x > y {
		x
	} else {
		y
	}
}
```

ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼š

- ç¼–è¯‘å™¨è€ƒè™‘çš„ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œæ— éœ€æ˜¾ç¤ºæ ‡æ³¨
- å¦‚æœç¼–è¯‘å™¨æ— æ³•æ¨æ–­ï¼Œåˆ™ç¼–è¯‘é”™è¯¯
- è¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼šå‡½æ•°/æ–¹æ³•çš„å‚æ•°
- è¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼šå‡½æ•°/æ–¹æ³•çš„è¿”å›å€¼
- è§„åˆ™é€‚ç”¨äº fn å®šä¹‰å’Œ impl å—

ä¸‰ä¸ªçœç•¥è§„åˆ™ï¼š

1. æ¯ä¸ªå¼•ç”¨ç±»å‹çš„å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼›
2. å¦‚æœåªæœ‰ 1 ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼›
3. å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ &self æˆ– &mut selfï¼ˆæ–¹æ³•ï¼‰ï¼Œé‚£ä¹ˆ self çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼›


## 18. æµ‹è¯•

- æµ‹è¯•ï¼š`#[cfg(test)]`ã€`#[test]`
- æ–­è¨€ï¼š`assert!`ã€`assert_eq!`ã€`assert_ne!`
- ææ…Œï¼š`#[should_panic]`
- å¯ä½¿ç”¨ `Result<T, E>` ä½œä¸ºè¿”å›ç±»å‹
- é»˜è®¤ `cargo test` å¹¶è¡Œè¿è¡Œæµ‹è¯•ï¼Œæ§åˆ¶çº¿ç¨‹æ•°é‡ `--test-threads`
- æµ‹è¯•é€šè¿‡ï¼Œä¸ä¼šçœ‹åˆ°æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„å†…å®¹ï¼›å¦åˆ™å¯ä»¥çœ‹åˆ°
- æŒ‡å®šæµ‹è¯•åç§°è¿è¡Œæµ‹è¯•ï¼š`cargo test test-name`
- å¿½ç•¥æµ‹è¯•ï¼š`#[ignore]`
- åªè¿è¡Œè¢«å¿½ç•¥çš„æµ‹è¯•ï¼š`cargo test -- --ignored`
- é›†æˆæµ‹è¯•ï¼š`tests`ç›®å½•
- ç¯å¢ƒå˜é‡ï¼š`env::var("xx")`
- æ ‡å‡†è¾“å‡ºï¼š`println!`
- æ ‡å‡†é”™è¯¯ï¼š`eprintln!`

## 19. é—­åŒ…

- åŒ¿åå‡½æ•°ï¼Œå¯ä»¥ä¿å­˜ä¸ºå˜é‡ã€ä½œä¸ºå‚æ•°
- é—­åŒ…ä¸è¦æ±‚æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œç¼–è¯‘å™¨é€šå¸¸èƒ½æ¨æ–­å‡ºç±»å‹ï¼›ä½†ä¹Ÿå¯ä»¥æ‰‹åŠ¨æ·»åŠ ç±»å‹æ ‡æ³¨
- è®°å¿†åŒ–ï¼ˆmemoizationï¼‰ï¼šåˆ›å»ºä¸€ä¸ª structï¼Œ**å®ƒæŒæœ‰é—­åŒ…åŠå…¶è°ƒç”¨ç»“æœ**
	- struct ä¸­éœ€è¦æŒ‡æ˜é—­åŒ…çš„ç±»å‹
	- **æ¯ä¸ªé—­åŒ…å®ä¾‹éƒ½æœ‰è‡ªå·±å”¯ä¸€çš„åŒ¿åç±»å‹**ï¼Œå³ä½¿ä¸¤ä¸ªé—­åŒ…ç­¾åå®Œå…¨ä¸€æ ·
	- éœ€è¦ä½¿ç”¨ï¼š**æ³›å‹å’Œ Trait Bound**
- **æ‰€æœ‰çš„é—­åŒ…éƒ½è‡³å°‘å®ç°äº†ä»¥ä¸‹ trait ä¹‹ä¸€**ï¼š
	- Fn
	- FnMut
	- FnOnce
- **é—­åŒ…å¯ä»¥è®¿é—®å®šä¹‰å®ƒçš„ä½œç”¨åŸŸå†…çš„å˜é‡ï¼Œè€Œæ™®é€šå‡½æ•°åˆ™ä¸èƒ½**
	- ä¼šäº§ç”Ÿå†…å­˜å¼€é”€
	- é—­åŒ…ä»æ‰€åœ¨ç¯å¢ƒä¸­æ•è·å€¼çš„æ–¹å¼ï¼š
		- å–å¾—æ‰€æœ‰æƒï¼šFnOnce
		- å¯å˜å€Ÿç”¨ï¼šFnMut
		- ä¸å¯å˜å€Ÿç”¨ï¼šFn
	- Rustå¦‚ä½•æ¨æ–­å…·ä½“ä½¿ç”¨å“ªä¸ª traitï¼š
		- æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº† FnOnce
		- æ²¡æœ‰ç§»åŠ¨æ•è·å˜é‡çš„å®ç°äº† FnMut
		- æ— éœ€å¯å˜è®¿é—®æ•è·å˜é‡çš„é—­åŒ…å®ç°äº† Fn
- `move` å…³é”®å­—ï¼š**å¯ä»¥å¼ºåˆ¶é—­åŒ…å–å¾—å®ƒæ‰€ä½¿ç”¨çš„ç¯å¢ƒå€¼çš„æ‰€æœ‰æƒ**
	åœºæ™¯ï¼šå½“å°†é—­åŒ…ä¼ é€’ç»™æ–°çº¿ç¨‹ä»¥ç§»åŠ¨æ•°æ®ä½¿å…¶å½’æ–°çº¿ç¨‹æ‰€æœ‰æ—¶
- æœ€ä½³å®è·µï¼šå½“æŒ‡å®š Fn trait bound ä¹‹ä¸€æ—¶ï¼Œé¦–å…ˆç”¨ Fnï¼ŒåŸºäºé—­åŒ…ä½“é‡Œçš„æƒ…å†µï¼Œç¼–è¯‘å™¨ä¼šå†å‘Šè¯‰ä½ éœ€è¦ä½¿ç”¨ FnOnce æˆ– FnMut

```rust
let c1 = |x: u32| -> u32 { x + 1 };
let c2 = |x| { x + 1 };
let c3 = |x| x + 1;

let x = vec![1,2,3];
let eq_x = move |z| z == x;
// x å·²å‘ç”Ÿç§»åŠ¨ï¼Œè¿™åé¢æ— æ³•å†ä½¿ç”¨x
```

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    map: HashMap<u32, u32>,
}

impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            map: HashMap::new(),
        }
    }

    fn value(&mut self, key: u32) -> u32 {
        let v = self.map.get(&key);
        match v {
            Some(i) => *i,
            None => {
                let calc = (self.calculation)(key);
                self.map.insert(key, calc);
                calc
            }
        }
    }
}

fn main() {
    let mut closure = Cacher::new(|num| {
        println!("calculation slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    println!("one {}", closure.value(99));
    println!("two {}", closure.value(99));
    println!("three {}", closure.value(99));
    println!("one {}", closure.value(100));
    println!("two {}", closure.value(100));
}
```

## 20. è¿­ä»£å™¨

- æ‰€æœ‰çš„è¿­ä»£å™¨éƒ½å®ç°äº† `Iterator trait`
	- å®ç° `Iterator trait` éœ€è¦å®šä¹‰ä¸ª Item ç±»å‹ï¼Œå®ƒç”¨äº next æ–¹æ³•çš„è¿”å›ç±»å‹
	- next æ¯æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€é¡¹ï¼Œè¿”å›ç»“æœåŒ…è£¹åœ¨ Some é‡Œï¼Œè¿­ä»£ç»“æŸåˆ™è¿”å› None
- `iter` æ–¹æ³•ï¼šåœ¨ä¸å¯å˜å¼•ç”¨ä¸Šåˆ›å»ºè¿­ä»£å™¨
- `into_iter` æ–¹æ³•ï¼šåˆ›å»ºçš„è¿­ä»£å™¨ä¼šè·å¾—æ‰€æœ‰æƒ
- `iter_mut` æ–¹æ³•ï¼šè¿­ä»£å¯å˜çš„å¼•ç”¨
- æ¶ˆè€—è¿­ä»£å™¨çš„æ–¹æ³•ï¼šnextã€sumç­‰
- è¿­ä»£å™¨é€‚é…å™¨ï¼šæŠŠè¿­ä»£å™¨è½¬æ¢ä¸ºä¸åŒç§ç±»çš„è¿­ä»£å™¨ï¼›æ¯”å¦‚ mapã€filter

```rust
pub trait Iterator {
	type Item;
	fn next(&mut self) -> Option<Self::Item>;
}

let v1 = vec![1, 3, 4, 6, 7, 9, 10];
let it = v1.iter().filter(|x| *x % 2 == 0);
```

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let s: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();

    println!("{}", s);
}
```

## 21. å‘å¸ƒ

Cargo ä¸»è¦æœ‰ä¸¤ä¸ª profileï¼š

- dev profileï¼šé€‚ç”¨äºå¼€å‘ï¼Œcargo build
- release profileï¼šé€‚ç”¨äºå‘å¸ƒï¼Œcargo build --release

è‡ªå®šä¹‰ profileæ—¶ï¼Œåœ¨ `Cargo.toml` é‡Œæ·»åŠ  `[profile.xxx]` åŒºåŸŸï¼Œè¦†ç›–é»˜è®¤é…ç½®çš„å­é›†ã€‚

crate å®˜æ–¹æ³¨å†Œè¡¨ï¼š`https://crates.io` 

- ç™»å½•è´¦å·ï¼šcargo login [token]
- å‘å¸ƒï¼šcargo publish ï¼ˆä¸€æ—¦å‘å¸ƒï¼Œè¯¥ç‰ˆæœ¬ä»£ç æ— æ³•è¦†ç›–ï¼Œæ— æ³•åˆ é™¤ï¼‰
- æ’¤å›ä¸€ä¸ªç‰ˆæœ¬ï¼šcargo yank --vers 1.0.1 
- å–æ¶ˆæ’¤å›ï¼šcargo yank --vers 1.0.1 --undo
- å®‰è£…äºŒè¿›åˆ¶ crateï¼šcargo install

æ–‡æ¡£æ³¨é‡Šï¼šç”ŸæˆHTMLæ–‡æ¡£ï¼›ä½¿ç”¨ `///` ï¼›æ”¯æŒ Markdown

- `cargo doc`ã€`cargo dock --open`ï¼šç”Ÿæˆåœ¨ `target/doc` ç›®å½•ä¸‹
- å¸¸ç”¨ç« èŠ‚ï¼š
	- `# Examples`ï¼šcargo test å¯ä»¥æŠŠæ–‡æ¡£æ³¨é‡Šä¸­çš„ç¤ºä¾‹ä»£ç ä½œä¸ºæµ‹è¯•æ¥è¿è¡Œ
	- `# Panics`ï¼šå‡½æ•°å¯èƒ½å‘ç”Ÿ panic 
	- `# Errors`ï¼šå¦‚æœå‡½æ•°è¿”å› Resultï¼Œæè¿°å¯èƒ½çš„é”™è¯¯ç§ç±»ï¼Œä»¥åŠå¯å¯¼è‡´é”™è¯¯çš„æ¡ä»¶
	- `# Safety`ï¼šå¦‚æœå‡½æ•°å¤„äº unsafe è°ƒç”¨ï¼Œå°±åº”è¯¥è§£é‡Šå‡½æ•° unsafe çš„åŸå› ï¼Œä»¥åŠè°ƒç”¨è€…ç¡®ä¿çš„ä½¿ç”¨å‰æ

å¦‚æœæ˜¯æè¿° crate å’Œæ¨¡å—çš„æ³¨é‡Šï¼Œæˆ–è®°å½•ä¸€ä¸ªæ¨¡å—æ•´ä½“ï¼Œä½¿ç”¨ `//!`

ä½¿ç”¨ `pub use` å¯¼å‡ºæ–¹ä¾¿ä½¿ç”¨çš„å…¬å…± API

å·¥ä½œç©ºé—´ï¼š

- ç®¡ç†å¤šä¸ªå…³è”ä¸”éœ€ååŒå¼€å‘çš„crate
- å°±æ˜¯ä¸€å¥—å…±äº«åŒä¸€ä¸ª Cargo.lock å’Œè¾“å‡ºæ–‡ä»¶å¤¹çš„åŒ…

è‡ªå®šä¹‰å‘½ä»¤æ‰©å±• cargoï¼š

- äºŒè¿›åˆ¶ cargo-abcï¼›è¿è¡Œå‘½ä»¤`cargo abc`
- cargo --list

