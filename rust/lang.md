# è¯­è¨€åŸºç¡€

## 1. å˜é‡ã€å¸¸é‡ã€éšè—

- **`let`** å…³é”®å­—ï¼šå£°æ˜å˜é‡ã€‚
	1. å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ `Immutable`
	2. åŠ ä¸Š**`mut`**ï¼Œä½¿å˜é‡å¯å˜

- **`const`** å…³é”®å­—ï¼šå£°æ˜å¸¸é‡ã€‚
	1. ä¸å¯ä»¥ç”¨ `mut`
	2. å¿…é¡»æ ‡æ³¨ç±»å‹
	3. å¯ä»¥å£°æ˜åœ¨ä»»ä½•ä½œç”¨åŸŸ
	4. åªå¯ä»¥ç»‘å®šåˆ°å¸¸é‡è¡¨è¾¾å¼

- **`Shadowing`** ï¼šéšè—ã€‚
	1. å¯ä»¥ä½¿ç”¨ `let` å£°æ˜ åŒåæ–°å˜é‡ï¼Œæ–°çš„å˜é‡å°±ä¼š `shadow` ä¹‹å‰å£°æ˜çš„å˜é‡
	2. æ–°çš„å˜é‡ï¼Œç±»å‹å¯ä»¥ä¸ä¹‹å‰ä¸åŒ

## 2. æ•°æ®ç±»å‹ï¼šæ ‡é‡ç±»å‹ã€å¤åˆç±»å‹

- æ ‡é‡ç±»å‹ï¼š
	1. æ•´æ•°ï¼š`i8ã€u8ã€i16ã€u16ã€i32ã€u32ã€i64ã€u64ã€i128ã€u128ã€isizeã€usize`ã€‚é»˜è®¤ç±»å‹æ˜¯ `i32`
	> æ•´æ•°æº¢å‡ºï¼š
	> 	- debugç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼š panicï¼›
	> 	- releaseç¼–è¯‘ï¼šç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœå‘ç”Ÿæº¢å‡ºï¼Œä¼šæ‰§è¡Œ â€œç¯ç»•â€ æ“ä½œï¼Œä¸ä¼španicï¼›
	3. æµ®ç‚¹ï¼š`f32ã€f64`ã€‚é»˜è®¤ç±»å‹æ˜¯ `f64`
	4. å¸ƒå°”ï¼š`bool`ï¼›å€¼ä¸º`trueã€false`ï¼›å ç”¨ä¸€ä¸ªå­—èŠ‚å¤§å°
	5. å­—ç¬¦ï¼š`char`ï¼›ä½¿ç”¨å•å¼•å·ï¼›å ç”¨**4ä¸ªå­—èŠ‚**å¤§å°ï¼›æ˜¯**Unicodeæ ‡é‡å€¼**

- å¤åˆç±»å‹ï¼š
	1. å…ƒç»„ï¼šæ”¯æŒå¤šä¸ªç±»å‹çš„å€¼æ”¾ä¸€èµ·ï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›`let tup: (i32, f64, char) = (1, 2.0, 'a');`
	2. æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒï¼›é•¿åº¦æ˜¯å›ºå®šçš„ï¼›å­˜æ”¾åœ¨ **`stack`** ä¸Šï¼›`let arr: [i32; 3] = [1,2,3];`ï¼Œä½¿ç”¨å›ºå®šå€¼åˆå§‹åŒ–æ•°ç»„æ—¶ `let arr = [3; 5];`

## 3. å‡½æ•°

- è¯­å¥ï¼ˆstatementï¼‰ï¼šæ‰§è¡Œä¸€äº›åŠ¨ä½œçš„æŒ‡ä»¤
- è¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼šè®¡ç®—äº§ç”Ÿä¸€ä¸ªå€¼
- å‡½æ•°ä½“ï¼šç”±ä¸€ç³»åˆ— `statement` ç»„æˆï¼Œå¯é€‰çš„ç”±ä¸€ä¸ª `expression` ç»“æŸï¼›
- è¿”å›å€¼ï¼š`->` ç¬¦å·åå£°æ˜å‡½æ•°è¿”å›å€¼ç±»å‹ï¼›é€šå¸¸æ˜¯å‡½æ•°ä½“ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼›æå‰è¿”å›éœ€ä½¿ç”¨ `return` å…³é”®å­—

## 4. æ§åˆ¶æµ

- `if else`ï¼šæ¡ä»¶å¿…é¡»æ˜¯ `bool` ç±»å‹
- `loop`
- `while`
- `for`ï¼šå®‰å…¨ã€ç®€æ´
- `Range`ï¼š`rev` å¯ä»¥åè½¬ `Range`ï¼Œ`for num in (1..4).rev()`
- `match`

## 5. æ‰€æœ‰æƒ

æ‰€æœ‰æƒæ˜¯ `Rust æœ€æ ¸å¿ƒ`çš„ç‰¹æ€§ï¼Œå®ƒä½¿å¾— `Rust` æ— éœ€ `GC` å°±å¯ä»¥ä¿è¯å†…å­˜å®‰å…¨ã€‚

æ‰€æœ‰æƒå­˜åœ¨çš„åŸå› ï¼Œå°±æ˜¯ç®¡ç† `heap` æ•°æ®ï¼š

- è·Ÿè¸ªä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ `heap` çš„å“ªäº›æ•°æ®ï¼›
- æœ€å°åŒ– `heap` ä¸Šçš„é‡å¤æ•°æ®é‡ï¼›
- æ¸…ç† `heap` ä¸Šæœªä½¿ç”¨çš„æ•°æ®ä»¥é¿å…ç©ºé—´ä¸è¶³ï¼›

### 5.1. æ‰€æœ‰æƒè§„åˆ™

- æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸ªå˜é‡æ˜¯è¯¥å€¼çš„æ‰€æœ‰è€…ï¼›
- æ¯ä¸ªå€¼åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼›
- å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸï¼ˆscopeï¼‰æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤ï¼›

### 5.2. å†…å­˜å’Œåˆ†é…

- **å½“å˜é‡èµ°å‡ºä½œç”¨åŸŸæ—¶ï¼ŒRust ä¼šè‡ªåŠ¨è°ƒç”¨`drop`å‡½æ•°ï¼Œå°†å†…å­˜è¿˜ç»™æ“ä½œç³»ç»Ÿ**ï¼›

- **ç§»åŠ¨ï¼ˆMoveï¼‰**ï¼š
![move](images/move.png)

æŠŠ s1 èµ‹å€¼ç»™ s2 , ä¸ºäº†ä¿è¯å†…å­˜å®‰å…¨ï¼š

	Ruståªåœ¨ `stack` ä¸Šå¤åˆ¶ï¼Œæ²¡æœ‰åœ¨ `heap` ä¸Šå¤åˆ¶ï¼›
	Rustè®© s1 å¤±æ•ˆï¼›

å¦‚æœçœŸçš„æƒ³å¯¹ `heap` ä¸Šçš„æ•°æ®åš `æ·±åº¦æ‹·è´`ï¼Œå¯ä»¥ä½¿ç”¨ `clone` æ–¹æ³•ã€‚

- **å¤åˆ¶**ï¼š
	- å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† `Copy trait`ï¼Œé‚£ä¹ˆæ—§çš„å˜é‡åœ¨èµ‹å€¼åä»ç„¶å¯ç”¨ï¼›
	- å¦‚æœä¸€ä¸ªç±»å‹æˆ–è¯¥ç±»å‹çš„ä¸€éƒ¨åˆ†å®ç°äº† `Drop trait`ï¼Œé‚£ä¹ˆ Rust ä¸å…è®¸è®©å®ƒå†å»å®ç° `Copy trait`ï¼›

**ç®€å•è¯´ï¼Œstackä¸Šçš„èµ„æºæœ‰copy traitï¼Œheapä¸Šçš„èµ„æºæ²¡æœ‰copy traitã€‚**

ä¸€äº›æ‹¥æœ‰ Copy trait çš„ç±»å‹ï¼š

- æ ‡é‡ç±»å‹
- å…ƒç»„ï¼Œå‰ææ˜¯æ‰€æœ‰å­—æ®µéƒ½æ˜¯copyçš„

### 5.3. å‡½æ•°

- å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå°†å‘ç”Ÿ **ç§»åŠ¨** æˆ– **å¤åˆ¶**ï¼›
- å‡½æ•°åœ¨è¿”å›å€¼çš„è¿‡ç¨‹ä¸­ï¼ŒåŒæ ·ä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»ï¼›

ä¸€ä¸ªå˜é‡çš„æ‰€æœ‰æƒï¼Œæ€»æ˜¯éµå¾ªåŒæ ·çš„æ¨¡å¼ï¼š

- æŠŠä¸€ä¸ªå€¼èµ‹ç»™å…¶ä»–å˜é‡æ—¶ï¼Œå°±ä¼šå‘ç”Ÿç§»åŠ¨ï¼›
- å½“ä¸€ä¸ªåŒ…å« `heap` æ•°æ®çš„å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„å€¼å°±ä¼šè¢« `drop` å‡½æ•°æ¸…ç†ï¼Œé™¤éæ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªå˜é‡ä¸Šäº†ï¼›

## 6. å¼•ç”¨å’Œå€Ÿç”¨

- å¼•ç”¨ï¼š`&`ç¬¦å·ï¼Œå…è®¸å¼•ç”¨æŸäº›å€¼è€Œ**ä¸å–å¾—å…¶æ‰€æœ‰æƒ**ï¼›é»˜è®¤ä¸å¯å˜çš„ï¼›
- å€Ÿç”¨ï¼šæŠŠå¼•ç”¨ä½œä¸ºå‡½æ•°å‚æ•°è¿™ä¸ªè¡Œä¸ºå«åšå€Ÿç”¨ï¼›`fn calc_len(s: & String) -> usize`
- å¯å˜å¼•ç”¨ï¼šæ¯”å¦‚`mut & String`ï¼›**åœ¨ç‰¹å®šä½œç”¨åŸŸå†…ï¼ŒæŸå—æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚ï¼ˆé¿å…ç«äº‰ï¼‰**ï¼›
	- ä¸å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨å’Œä¸€ä¸ªä¸å¯å˜å¼•ç”¨
	- å¯ä»¥åŒæ—¶æ‹¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨

## 7. åˆ‡ç‰‡ï¼ˆsliceï¼‰

åˆ‡ç‰‡ï¼ˆsliceï¼‰ï¼š`&str`ï¼Œä¹Ÿæ˜¯ä¸€ç§**ä¸æŒæœ‰æ‰€æœ‰æƒ**çš„æ•°æ®ç±»å‹ï¼›

- å­—ç¬¦ä¸²åˆ‡ç‰‡çš„èŒƒå›´ç´¢å¼•å¿…é¡»å‘ç”Ÿåœ¨æœ‰æ•ˆçš„ UTF-8 å­—ç¬¦è¾¹ç•Œå†…ï¼›
- å¦‚æœå¯¹ä¸€ä¸ª**å¤šå­—èŠ‚çš„å­—ç¬¦**ä¸­åˆ›å»ºå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç¨‹åºæŠ¥é”™å¹¶é€€å‡ºï¼›

## 8. ç»“æ„ä½“ï¼ˆstructï¼‰

- ä¸€æ—¦ struct çš„å®ä¾‹æ˜¯å¯å˜çš„ï¼Œé‚£ä¹ˆå®ä¾‹ä¸­çš„æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯å˜çš„ï¼›

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User { // ä½œä¸ºå‡½æ•°è¿”å›å€¼
        active: true,
        username, // ç®€å†™
        email,    // ç®€å†™
        sign_in_count: 1,
    }
}

let u1 = build_user(String::from("joe@163.com"), String::from("joe"));

let u2 = User {
    email: String::from("tom@163.com"),
    username: String::from("tom"),
    ..u1   // struct æ›´æ–°è¯­æ³•
};

// Tuple struct
// structæœ‰åï¼Œä½†é‡Œé¢å…ƒç´ æ²¡å
struct Point(i32, i32, i32);
let origin = Point(4, 5, 6);

// Unit-Like struct
// æ²¡æœ‰ä»»ä½•å­—æ®µï¼Œé€‚ç”¨äºéœ€è¦åœ¨æŸä¸ªç±»å‹ä¸Šå®ç°æŸä¸ª traitï¼Œä½†é‡Œé¢æœ‰æ²¡æœ‰éœ€è¦å­˜å‚¨çš„æ•°æ®
struct Solution;
```

- **æ–¹æ³•**ï¼šåœ¨ `impl` å—å®šä¹‰æ–¹æ³•ï¼›æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯ `&self`ï¼Œä¹Ÿå¯ä»¥è·å¾—å…¶æ‰€æœ‰æƒ æˆ– å¯å˜å€Ÿç”¨ï¼›
- **å…³è”å‡½æ•°**ï¼šåœ¨ `impl` å—å®šä¹‰ï¼Œä¸æŠŠ `self` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼›

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // å…³è”å‡½æ•°
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size
        }
    }
}
```

## 9. æšä¸¾ï¼ˆenumï¼‰

- å¯ä»¥å°†æ•°æ®é™„åŠ åˆ°æšä¸¾çš„å˜ä½“ä¸­
- æ¯ä¸ªå˜ä½“å¯ä»¥æ‹¥æœ‰ä¸åŒçš„ç±»å‹ä»¥åŠå…³è”çš„æ•°æ®é‡
- ä½¿ç”¨`impl`ä¸ºæšä¸¾å®šä¹‰æ–¹æ³•

```rust
#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        println!("{:?}", self);
    }
}
```

Rust æä¾›äº†ç±»ä¼¼ `Null` æ¦‚å¿µçš„æšä¸¾ï¼š`Option<T>`

- `Option<T>` å’Œ `T` æ˜¯ä¸åŒçš„ç±»å‹ï¼›
- è‹¥éœ€è¦ä½¿ç”¨`Option<T>`ä¸­çš„`T`ï¼Œéœ€è¦å…ˆè½¬æ¢ï¼›

```rust
enum Option<T> {
    Some(T),
    None,
}
```

## 10. match

- å…è®¸ä¸€ä¸ªå€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡ŒåŒ¹é…ï¼Œå¹¶æ‰§è¡ŒåŒ¹é…çš„æ¨¡å¼å¯¹åº”çš„ä»£ç 
- `æ¨¡å¼`å¯ä»¥æ˜¯å­—é¢å€¼ã€å˜é‡åã€é€šé…ç¬¦...
- æ¨¡å¼å¯ä»¥ç»‘å®šå€¼ï¼Œæ¯”å¦‚ä» enum å˜ä½“ä¸­æå–å€¼ï¼›
- match åŒ¹é…**å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„å¯èƒ½**ï¼›å¦‚æœä¸æƒ³å¤„ç†ï¼Œåˆ™ä½¿ç”¨ `_ é€šé…ç¬¦`æ¥æ›¿ä»£å…¶ä½™å€¼ï¼›

```rust
let x = Some(5);
match x {
    None => None,
    Some(i) => Some(i + 1),
}

let v = 0u8;
match v {
    1 => 1,
    3 => 3,
    5 => 5,
    _ => 999,
}
```

## 11. if let

- åª**å…³å¿ƒä¸€ç§åŒ¹é…**è€Œå¿½ç•¥å…¶ä»–åŒ¹é…çš„æƒ…å†µï¼›
- æ”¾å¼ƒäº†ç©·ä¸¾çš„å¯èƒ½ï¼›

```rust
let x = Some(5);
if let Some(5) = x {
    println!("five")
} else {
	println!("others")
}
```

## 12. Packageã€Crateã€Moduleã€Path

- `Crate`ï¼š
	- ä¸¤ç§ç±»å‹ï¼š`binary`ã€`library`
	- `Crate Root`ï¼šæŒ‡æºä»£ç å…¥å£æ–‡ä»¶
		- `src/main.rs`  ( binary )
		- `src/lib.rs`  ( library )

- `Package`ï¼š
	- `Cargo.toml`ï¼šæè¿°äº†å¦‚æœæ„å»º `Crates`
	- åªèƒ½åŒ…å« `0-1` ä¸ª `library crate`
	- å¯ä»¥åŒ…å« `ä»»æ„æ•°é‡` çš„ `binary crate`
	- ä½†å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª `crate`

- `Module`ï¼šåœ¨ä¸€ä¸ª `crate` å†…ï¼Œå°†ä»£ç è¿›è¡Œåˆ†ç»„
	- æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§ï¼ˆpublicã€privateï¼‰
	- **`mod`** å…³é”®å­—ï¼Œå¯åµŒå¥—

- `Path`ï¼š
	- ä¸¤ç§å½¢å¼ï¼šç»å¯¹è·¯å¾„ï¼ˆæ¨èï¼‰ã€ç›¸å¯¹è·¯å¾„
	- æ ‡è¯†ç¬¦ `::`
	- **`super`** å…³é”®å­—ï¼Œç”¨æ¥è®¿é—®çˆ¶çº§æ¨¡å—è·¯å¾„ä¸­çš„å†…å®¹ï¼Œç±»ä¼¼æ–‡ä»¶ç³»ç»Ÿä¸­çš„`..`

- `privacy boundary`ï¼šç§æœ‰è¾¹ç•Œ
	- Rustä¸­æ‰€æœ‰æ¡ç›®ï¼ˆå‡½æ•°ã€æ–¹æ³•ã€structã€enumã€æ¨¡å—ã€å¸¸é‡ï¼‰**é»˜è®¤æ˜¯ç§æœ‰çš„**ã€‚
	- çˆ¶æ¨¡å—æ— æ³•è®¿é—®å­æ¨¡å—çš„ç§æœ‰æ¡ç›®
	- å­æ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ç¥–å…ˆæ¨¡å—ä¸­çš„æ¡ç›®
	- **`pub`** å…³é”®å­—æ ‡è®°æ¡ç›®ä¸ºå…¬å…±çš„

- **`pub struct`**ï¼š
	- `struct` æ˜¯å…¬å…±çš„ï¼Œä½†**é‡Œé¢çš„å­—æ®µé»˜è®¤æ˜¯ç§æœ‰çš„**
	- é‡Œé¢çš„å­—æ®µéœ€è¦å•ç‹¬è®¾ç½® `pub` æ¥å˜æˆå…¬æœ‰çš„

- **`pub enum`**ï¼š
	- `enum` æ˜¯å…¬å…±çš„ï¼Œ
	- **`enum` çš„å˜ä½“ä¹Ÿéƒ½æ˜¯å…¬å…±çš„**

- **`use`**ï¼šå°† `path` å¯¼å…¥åˆ°ä½œç”¨åŸŸå†…ï¼Œï¼ˆä½œç”¨åŸŸå†…**ç§æœ‰**ï¼‰
	- å‡½æ•°ï¼šæƒ¯ç”¨åšæ³•æ˜¯å°†å‡½æ•°çš„çˆ¶çº§æ¨¡å—å¼•å…¥ä½œç”¨åŸŸï¼ˆæŒ‡å®šçˆ¶çº§ï¼‰
	- `structã€enum`ï¼šæƒ¯ç”¨åšæ³•æŒ‡å®šå®Œæ•´è·¯å¾„ï¼ˆæŒ‡å®šæœ¬çœï¼‰ï¼ˆé™¤éä¸¤ä¸ªæ¨¡å—ä¸­çš„ç»“æ„ä½“åç§°ç›¸åŒï¼‰
	- **`as`** å…³é”®å­—ï¼šå¯ä»¥ç»™å¼•å…¥è·¯å¾„æŒ‡å®šï¼ˆæœ¬åœ°ï¼‰åˆ«å
	- **`pub use`**ï¼šé‡æ–°å¯¼å‡ºåç§°
	- å¯ä»¥ä½¿ç”¨ **åµŒå¥—è·¯å¾„** æ¸…ç†å¤§é‡çš„ `use` è¯­å¥
	- æ”¯æŒé€šé…ç¬¦ `*`

```rust
// åµŒå¥—è·¯å¾„
use std::{cmp::Ordering, io}
use std::io::{self, Write}
```

- **å°†æ¨¡å—å†…å®¹ç§»åŠ¨åˆ°å…¶ä»–æ–‡ä»¶**
	- æ¨¡å—ååé¢æ˜¯ `;`
	- Rust ä¼šä»ä¸æ¨¡å—åŒåçš„æ–‡ä»¶ä¸­åŠ è½½å†…å®¹

## 13. Vectorã€Stringã€HashMap

- Vector

```rust
// Vector
let mut v: Vec<i32> = Vec::new();
let mut v1 = vec![1,2,3];
v.push(99);
v.get(0);
for item in  v {}
for (i, item) in v.iter().enumerate() {}

enum Cell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    Cell::Int(1),
    Cell::Float(2.34),
    Cell::Text(String::from("red")),
]
```

- Stringï¼š**å­—ç¬¦ä¸²åœ¨Rustä¸­ä½¿ç”¨ `UTF-8` ç¼–ç **
	- `String`  æ¥è‡ªæ ‡å‡†åº“
	- `&str` å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œæ¥è‡ªRustæ ¸å¿ƒè¯­è¨€
	- å…¶ä»–å­—ç¬¦ä¸²ç±»å‹ï¼š`OsStringã€OsStrã€CStringã€CStr`
	- **Rustä¸­å­—ç¬¦ä¸²ä¸æ”¯æŒç´¢å¼•è¯­æ³•è®¿é—®**ã€‚åŸå› ï¼š
		- 1. ä¸å®‰å…¨ï¼Œè¶Šç•Œé—®é¢˜ï¼›
		- 2. ç´¢å¼•æ“ä½œåº”æ¶ˆè€—O(1)ï¼Œä½†Stringæ— æ³•ä¿è¯è¿™ä¸ªæ—¶é—´ï¼Œå› ä¸ºéœ€è¦éå†æ‰€æœ‰å†…å®¹æ‰èƒ½ç¡®å®šæœ‰å¤šå°‘åˆæ³•å­—ç¬¦ï¼›
	- `String` æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…
	- Rustä¸­çœ‹å¾…å­—ç¬¦ä¸²æœ‰ä¸‰ç§æ–¹å¼ï¼š
		- å­—èŠ‚ï¼ˆBytesï¼‰
		- æ ‡é‡å€¼ï¼ˆScalar Valuesï¼‰
		- å­—å½¢ç°‡ï¼ˆGrapheme Clustersï¼‰
	- Rustä¸­ï¼Œ**å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ‰€å çš„å­—èŠ‚æ•°æ˜¯å˜åŒ–çš„**ï¼ˆ**`1-4`ä¸ªå­—èŠ‚**ï¼‰
	- åˆ‡å‰²å­—ç¬¦ä¸²ï¼Œå¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œ**å¦‚æœè·¨è¶Šäº†å­—ç¬¦è¾¹ç•Œï¼Œç¨‹åºå°±ä¼španic**ã€‚

```rust
let blue = "Blue".to_string();
let mut red = String::from("Red");
red.push_str("black");
red.push_str(&blue);  // é™„åŠ å­—ç¬¦ä¸²åˆ‡ç‰‡
red.push('ğŸ˜‚');      // é™„åŠ å•ä¸ªå­—ç¬¦

let color = red + &blue; // fn add(self, s: &str) -> String
// æ³¨æ„ï¼šredå‘ç”Ÿäº†ç§»åŠ¨ï¼Œæ‰€æœ‰æƒè¿›è¡Œäº†è½¬ç§»ï¼Œåç»­æ— æ³•ç»§ç»­ä½¿ç”¨

let s = format!("{}-{}", "foo", "bar");

// å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç 
println!("{}", "a".len());  // æ‰“å° 1
println!("{}", "Ğ´".len());  // æ‰“å° 2
println!("{}", "à¤µ".len());  // æ‰“å° 3
println!("{}", "ğŸ˜‚".len()); // æ‰“å° 4

// éå†
for i in color.chars() {}  // æƒ³å¾—åˆ° æ ‡é‡å€¼
for i in color.bytes() {}  // æƒ³å¾—åˆ° å­—èŠ‚
```

- HashMap
	- åœ¨å…ƒç´ ç±»å‹ä¸º `Tuple`ï¼ˆä¸¤ä¸ªå€¼ï¼‰ çš„ `Vector` ä¸Šä½¿ç”¨ `collect`æ–¹æ³•ï¼Œå¯ä»¥ç»„å»ºä¸€ä¸ª `HashMap` 
	- **æ‰€æœ‰æƒ**ï¼š
		- **å¯¹äºå®ç°äº† `Copy trait` çš„ç±»å‹ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ° `HashMap` ã€‚**æ¯”å¦‚ `i32` 
		- **å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œå€¼ä¼šè¢«ç§»åŠ¨ï¼Œæ‰€æœ‰æƒä¼šè½¬ç§»ç»™ `HashMap` ã€‚**æ¯”å¦‚ `String` 
		- å¦‚æœå°†**å€¼çš„å¼•ç”¨**æ’å…¥åˆ° `HashMap` ï¼Œå€¼æœ¬èº«ä¸ä¼šç§»åŠ¨ï¼›ä½†è¿™æœŸé—´å¿…é¡»ä¿æŒå¼•ç”¨çš„å€¼æœ‰æ•ˆ
	- **Hashå‡½æ•°**ï¼š
		- é»˜è®¤æƒ…å†µä¸‹çš„hashå‡½æ•°ï¼Œå¯ä»¥æŠµæŠ—Dosæ”»å‡»ï¼Œå®‰å…¨æ€§æ›´å¥½ï¼Œä½†ä¸æ˜¯æœ€å¿«çš„ç®—æ³•ï¼›
		- å¯ä»¥æŒ‡å®šä¸åŒçš„ `hasher` ï¼ˆæŒ‡å®ç°äº† `BuildHasher trait` çš„ç±»å‹ï¼‰æ¥åˆ‡æ¢ï¼›

```rust
let mut map: HashMap<i32, String> = HashMap::new();
map.insert(10, String::from("red"));
let v = map.get(&10);
match v {
    None => println!("not exist"),
    Some(s) => println!("{}", s),
}

let color = vec![String::from("red"), String::from("blue")];
let nums = vec![100, 200];
let mut map: HashMap<_, _> = color.iter().zip(nums.iter()).collect();
for (k,v) in &map {
    println!("{}: {}", k, v)
}
map.entry(&String::from("black")).or_insert(&300); // keyä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥

let text = "hello world wonderful world";
let mut map = HashMap::new();
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
println!("{:#?}", map);
// entryæ–¹æ³•ï¼šè¿”å› enum Entryï¼Œä»£è¡¨å€¼æ˜¯å¦å­˜åœ¨
// or_insertæ–¹æ³•ï¼š
//        å¦‚æœ key å­˜åœ¨ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
//        å¦‚æœ key ä¸å­˜åœ¨ï¼Œå°†æ–°é”®å€¼(k,v)æ’è¿›å»ï¼Œè¿”å› value çš„å¯å˜å¼•ç”¨ï¼›
```

## 14. é”™è¯¯å¤„ç†

- å¯æ¢å¤ï¼š`Result<T, E>`
- ä¸å¯æ¢å¤ï¼š`panic!` å®

**panicï¼š**

- é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ panic å‘ç”Ÿæ—¶ï¼Œç¨‹åºä¼š **å±•å¼€ï¼ˆunwindï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆRustæ²¿è°ƒç”¨æ ˆå¾€å›èµ°ï¼Œæ¸…ç†æ¯ä¸€ä¸ªé‡åˆ°çš„æ•°æ®ï¼‰
- æƒ³è®©äºŒè¿›åˆ¶æ–‡ä»¶æ›´å°ï¼Œå¯ä»¥æŠŠè¿™ä¸€è¡Œä¸ºæ”¹ä¸º **ç«‹å³ä¸­æ­¢ï¼ˆabortï¼‰** è°ƒç”¨æ ˆï¼›ï¼ˆç”±OSè¿›è¡Œæ¸…ç†ï¼‰
	- åœ¨Cargo.tomlä¸­è®¾ç½®ï¼š
```toml
[profile.release]
panic = 'abort'
```
- å›æº¯ä¿¡æ¯ï¼šè®¾ç½®ç¯å¢ƒå˜é‡ `RUST_BACKTRACE`ï¼›debugæ¨¡å¼ï¼›

**Resultæšä¸¾ï¼š**

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

**é”™è¯¯å¤„ç†ï¼š**

- **`match`**
- **`unwrap`**ï¼šmatchè¡¨è¾¾å¼çš„ä¸€ä¸ªå¿«æ·æ–¹å¼ï¼›
- **`expect`**ï¼šå¯æŒ‡å®šé”™è¯¯ä¿¡æ¯

```rust
let f = File::open("hello.ext").unwrap();
let f = File::open("hello.ext").expect("cannot open file");
```

**ä¼ æ’­é”™è¯¯ï¼š**

- **`?` è¿ç®—æ³•**ï¼šä¼ æ’­é”™è¯¯çš„å¿«æ·æ–¹å¼
- **`from` å‡½æ•°**ï¼šç”¨äºé”™è¯¯ä¹‹é—´çš„è½¬æ¢ï¼›åœºæ™¯ï¼šé’ˆå¯¹ä¸åŒçš„é”™è¯¯åŸå› ï¼Œè¿”å›åŒä¸€ç§é”™è¯¯ç±»å‹ï¼›
	- è¦æ±‚ï¼šæ¯ä¸ªé”™è¯¯ç±»å‹éƒ½å®ç°äº†è½¬æ¢ä¸ºæ‰€è¿”å›çš„é”™è¯¯ç±»å‹çš„fromå‡½æ•°ï¼›
- **`main` å‡½æ•°**çš„è¿”å›ç±»å‹æ˜¯ `()`ï¼Œ`main` å‡½æ•°çš„è¿”å›ç±»å‹ä¹Ÿå¯ä»¥æ˜¯ `Result<T, E>`
	- main è¿”å›ç±»å‹å†™ï¼š`Result<(), Box<dyn Error>>`
	- `Box<dyn Error>` æ˜¯ trait å¯¹è±¡ï¼Œè¡¨ç¤ºä»»ä½•å¯èƒ½çš„é”™è¯¯ç±»å‹ï¼›

```rust
fn open_file() -> Result<String, io::Error> {
    let f = File::open("hello.ext")?;
    Ok(String::from("ok"))
}

fn read_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.ext")?.read_to_string(&mut s)?;
    Ok(s)
}
```

## 15. æ³›å‹

- ä½¿ç”¨æ³›å‹çš„ä»£ç å’Œä½¿ç”¨å…·ä½“ç±»å‹çš„ä»£ç è¿è¡Œé€Ÿåº¦æ˜¯ä¸€æ ·çš„ã€‚
- å•æ€åŒ–ï¼ˆmonomorphizationï¼‰ï¼šåœ¨ç¼–è¯‘æ—¶å°†æ³›å‹æ›¿æ¢ä¸ºå…·ä½“ç±»å‹

```rust
// å‡½æ•°
fn largest<T>(list: &[T]) -> T {}

// ç»“æ„ä½“
struct Point<T, U> {
    x: T,
    y: U,
}

// æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// æ–¹æ³•
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {}
}
```

